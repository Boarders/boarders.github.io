<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title></title>
    <link href="https://boarders.github.io/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2023-08-21T03:52:SZ</updated>
  <author>
      <name>Callan Mcgill</name>
  </author>
  <id>https://boarders.github.io/</id>

  <entry>
      <title>The Halting Problem (part 1)</title>
      <link href="https://boarders.github.ioposts/halting1.html"/>
      <id>https://boarders.github.ioposts/halting1.html</id>
      <updated>2020-12-07T00:00:SZ</updated>
      <category term="Halting Problem"/>
      <category term="Haskell"/>
      <summary>Exploring the Halting problem in Haskell</summary>
      <content type="html"><![CDATA[<p>The halting problem states, informally, that there is no algorithm to
determine whether an <em>arbitrary</em> program (when provided with some
given input) will halt. Even for specific programs this can lead to
interesting unsolved questions. A well-known example is the <a
href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz
conjecture</a>, which states, that the following function halts for all
inputs:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">collatz ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>collatz <span class="dv">1</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>collatz n <span class="op">|</span> <span class="fu">even</span> n    <span class="ot">=</span> collatz (n <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>collatz n <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> collatz (<span class="dv">3</span> <span class="op">*</span> n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<pre class="terminal"><code>&gt; all id (fmap collatz [1..10000])
True</code></pre>
<p>Typically, the halting problem is formalised by first picking some
specific theory of computation, and then demonstrating, within that
theory, that no such halting algorithm can be written. Unfortunately,
the theory typically chosen is that of Turing machines. These are hard
to formalise (<a
href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition">Wikipedia</a>
informs me, for example, that â€œa (one-tape) Turing machine can be
formally defined as a [certain] 7-tupleâ€!) and donâ€™t offer a
particularly good foundation for programming. A Turing machine, after
all, is <em>not</em> (and was never meant to be) a programming
language!</p>
<p>Instead letâ€™s take an alternative approach: we will use the lambda
calculus as the basis for computation. The lambda calculus is both a
programming language in itself and the foundation of all other
functional languages. As a testament to this idea, we will first prove
halting for the lambda calculus and then see how the same argument looks
when transplanted to Haskell. Finally, in <a
href="https://boarders.github.io/posts/halting2.html">part two of this
post</a>, we will formalise the argument in Agda and fill in most of the
lingering details we brush aside here.</p>
<p>In the setting of the lambda calculus, a precise statement of halting
can be given thusly:</p>
<p><strong>Theorem (<span
class="math inline">\(\lambda\)</span>-Halting)</strong>: There does not
exist a <span class="math inline">\(\lambda\)</span>-term <span
class="math inline">\(\def\h{\mathbf{HALT}} \def\s{\text{ }}
\def\L{\mathrm{L}} \def\l{\mathrm{l}} \def\true{\mathbf{true}}
\def\false{\mathbf{false}} \h\)</span> such that for any given lambda
term <span class="math inline">\(\L\)</span>, <span
class="math inline">\(\h \text{ } \L\)</span> evaluates to <span
class="math inline">\(\true\)</span> when <span
class="math inline">\(\L\)</span> terminates and <span
class="math inline">\(\false\)</span> otherwise.</p>
<p>Here, by termination, we mean what is otherwise called normalization.
A term is normalizing if there exists a finite sequence of <a
href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction_2"><span
class="math inline">\(\beta\)</span>-reductions</a> (performed anywhere
within the term) after which, the term contains no further <span
class="math inline">\(\beta\)</span>-redexes. A well-known result in the
study of the lambda calculus says that a term normalizes if and only if
it normalizes when we always pick the leftmost, outermost redex. This
gives us an algorithm that will <em>confirm</em> that a given term does
indeed terminate but will never disconfirm whether a term loops
indefinitely. In other words, there is a <a
href="https://en.wikipedia.org/wiki/Decidability_(logic)#Semidecidability">semi-decision
procedure</a> for halting.</p>
<p>Letâ€™s turn to the proof of <span
class="math inline">\(\lambda\)</span>-Halting. The arguments here are
adapted from the introduction to the paper <a
href="https://www.sciencedirect.com/science/article/pii/0304397593900858">Computational
Foundations of Basic Recursive Function Theory</a> by Constable and
Smith. Essential to this argument is that lambda calculus allows us to
encode arbitrary recursive functions. Such recursion is performed by
fixed-point combinators. We will make use of perhaps the most well-known
fixed-point combinator (though any other would do for our purposes), the
<a
href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator"><span
class="math inline">\(\mathrm{Y}\)</span>-combinator</a>, defined as
follows:</p>
<p><span class="math display">\[
\def\Y{\mathrm{Y}}
\def\mr#1{\mathrm{#1}}
\def\la#1{\lambda \s \mathrm{#1} \s . \s }
\def\ap#1#2{\mathrm{#1} \s {\mathrm{#2}}}
\def\be{\mapsto_{\beta}}
\Y = \la{f} \ap{(\la{x} \ap{f}{(\ap{x}{x})})}{(\la{x}
\ap{f}{(\ap{x}{x})})}
  \]</span></p>
<p>The key property that fixed-point combinators satisfy is that for any
lambda term <span class="math inline">\(\rm{g}\)</span> we have that
<span class="math inline">\((\ap{\Y}{\rm{g}})\)</span> is a fixed point
for <span class="math inline">\(\rm{g}\)</span> in the sense that <span
class="math inline">\(\ap{g}{(\ap{\Y}{g})}\)</span> is <span
class="math inline">\(\beta\)</span>-equivalent to <span
class="math inline">\(\ap{\Y}{g}\)</span>. This is straightforward to
see as follows:</p>
<p><span class="math display">\[
     \begin{aligned}
      \ap{\Y}{g} \be \; &amp;\ap{(\la{x} \ap{g}{(\ap{x}{x})})}{(\la{x}
\ap{g}{(\ap{x}{x})})} \\
                 \be \; &amp;\ap{g}({\ap{(\la{x}
\ap{g}{(\ap{x}{x})})}{(\la{x} \ap{g}{(\ap{x}{x})})}}) \\
        \equiv_\beta \; &amp;\ap{g}{(\ap{Y}{g})}
    \end{aligned}\]</span></p>
<p>Fixed point combinators allow us to write recursive functions. For
example, supposing we have already <a
href="https://en.wikipedia.org/wiki/Church_encoding">encoded</a>
Booleans and Natural numbers as certain lambda terms. In a language
which allowed recursive definitions we could write: <span
class="math display">\[
  \mathrm{fact} (n) = \mathrm{if}\; n = 0\;
                        \mathrm{then} \; 1 \;
                        \mathrm{else} \; n * \;\mathrm{fact} (n - 1)
\]</span> In the lambda calculus we canâ€™t refer to the variables we are
defining in their body and so instead we make use of a fixed point
combinator like so: <span class="math display">\[
  \mathrm{fact} = \Y ( \la{f} \la{n} \mathrm{if}\; n = 0\;
                        \mathrm{then} \; 1 \;
                        \mathrm{else} \; n * f \; (n - 1))
\]</span></p>
<p>Given this, and supposing we are given such a <span
class="math inline">\(\h\)</span> term as above, we then introduce the
following terms:</p>
<p><span class="math display">\[
     \begin{aligned}
        \bot  &amp; = \ap{Y}{(\la{x}x)} \\
        \rm{p}&amp; = {\la{f}\text{if $(\ap{\h}{f})$ then $\bot$ else
true}} \\
        \rm{d}&amp; = \ap{Y}{p}
  \def\betaStep{\mapsto_{\beta}}
      \end{aligned}  \]</span></p>
<p>The suggestively named <span class="math inline">\(\bot\)</span> is
an infinitely looping expression:</p>
<p><span class="math display">\[
     \begin{aligned}
      \ap{\Y}({\la{x}x}) \be \;
        &amp;  \ap{(\la{x} x)}(\ap{\Y}({\la{x}x})) \\
        \be \; &amp;{\ap{Y}{(\la{x}x})}
    \end{aligned}\]</span></p>
<p>The term <span class="math inline">\(\rm{p}\)</span> takes any
argument <span class="math inline">\(\mathrm{f}\)</span> and returns
true if the argument doesnâ€™t terminate and otherwise loops forever. We
then define <span class="math inline">\(\mathrm{d}\)</span> as the fixed
point of this function. With ordinary recursion we would write this as
follows:</p>
<p><span class="math display">\[
  \rm{p} = \text{if } (\ap{\h}{\rm{p}}) \text{ then } \bot \text{
else  true}
\]</span></p>
<p>Intuitively, we can see the problem with this term - if it halts then
it reduces to <span class="math inline">\(\bot\)</span> and if it
doesnâ€™t halt then it reduces to <span
class="math inline">\(\mathrm{true}\)</span>. In slightly more
detail:</p>
<ul>
<li>if <span class="math inline">\(\ap{\h}{d}\)</span> is <span
class="math inline">\(\rm{true}\)</span> then: <span
class="math display">\[
\rm{d} \equiv_\beta \ap{p}{d} :\equiv
   \text{if $(\ap{\h}{d})$ then $\bot$ else true} \betaStep \bot
\]</span> We therefore have that <span
class="math inline">\(\rm{d}\)</span> does not terminate and so <span
class="math inline">\(\ap{\h}{d}\)</span> must be <span
class="math inline">\(\rm{false}\)</span>.</li>
<li>Similarly if <span class="math inline">\(\ap{\h}{d}\)</span> is
<span class="math inline">\(\rm{false}\)</span> then: <span
class="math display">\[
\rm{d} \equiv_\beta \ap{p}{d} :\equiv
   \text{if $(\ap{\h}{d})$ then $\bot$ else true} \betaStep \text{true}
  \]</span> and so we get that <span
class="math inline">\(\rm{d}\)</span> terminates and so we get that
<span class="math inline">\(\ap{\h}{d}\)</span> is true.</li>
</ul>
<p>Let us see how easily these concepts translate to a language like
Haskell. Note that in Haskell all types are <em>partial</em> (using
Constableâ€™s terminology). This means that every type is inhabited by
some non-terminating term; this is typically denoted <span
class="math inline">\(\bot\)</span> (analogous to the term considered
above). Reformulating the theorem with this in mind we get:</p>
<p><strong>Theorem (Haskell-Halting)</strong>: In Haskell there is no
function <span class="math inline">\(\mathbf{halt}\)</span> with the
following behaviour:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">halt ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>halt âŠ¥ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>halt _ <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>Of course, this specification is not legal Haskell (and moreover we
are claiming that no function can have this behaviour). This formulation
may appear slightly different to the Halting problem insomuch as we are
only considering the (partial) natural numbers, but we can observe that
for any <code>f :: Nat -&gt; Nat</code> we can use
<code>halt (f n)</code> to determine if <code>f</code> halts on input
<code>n</code>, and so this would allow us to determine on which inputs
<code>f</code> terminates.</p>
<p>In order to mimic the argument above, letâ€™s use a fixed point
function similar to <span class="math inline">\(\Y\)</span>, aptly named
<a
href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Function.html#v:fix"><span
class="math inline">\(\mathrm{fix}\)</span></a>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> f x <span class="kw">in</span> x</span></code></pre></div>
<p>We note that <span class="math inline">\(\rm{fix}\)</span> satisfies
precisely the same fixed-point property as <span
class="math inline">\(\Y\)</span>: <span class="math display">\[
  \ap{f}{(\ap{fix}{f})} \equiv_\beta \ap{fix}{f}
  \]</span></p>
<p>As in the lambda calculus, <span
class="math inline">\(\mathrm{fix}\)</span> allows us to capture all
forms of recursion in a single function. For instance, if we define an
â€œopenly recursiveâ€ sum function:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sumR ::</span> <span class="kw">forall</span> n <span class="op">.</span> (<span class="dt">Num</span> n) <span class="ot">=&gt;</span> ([n] <span class="ot">-&gt;</span> n) <span class="ot">-&gt;</span> ([n] <span class="ot">-&gt;</span> n)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>sumR recFn <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  []     <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  (x<span class="op">:</span>xs) <span class="ot">-&gt;</span> x <span class="op">+</span> recFn xs</span></code></pre></div>
<p>Then taking <span class="math inline">\(\mathrm{fix}\)</span>
recovers the usual sum:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mySum ::</span> <span class="kw">forall</span> n <span class="op">.</span> (<span class="dt">Num</span> n) <span class="ot">=&gt;</span> [n] <span class="ot">-&gt;</span> n</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>mySum <span class="ot">=</span> fix sumR</span></code></pre></div>
<pre class="shell"><code>&gt; mySum [1..100]
5050</code></pre>
<p>Recasting our problem terms from earlier we get:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bottom ::</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>bottom <span class="ot">=</span> fix <span class="fu">id</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>p n <span class="ot">=</span> <span class="kw">if</span> halt n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> bottom</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">d ::</span> <span class="dt">Natural</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> fix p</span></code></pre></div>
<p>As above let us think about the value of <span
class="math inline">\((\ap{h}{problem})\)</span>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    d</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  â‰¡ fix d</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  â‰¡ p d</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  â‰¡ <span class="kw">if</span> halt d <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> bottom</span></code></pre></div>
<p>As before:</p>
<ul>
<li>If <code>halt d</code> is <span class="math inline">\(0\)</span>
then it is 1.</li>
<li>If <code>halt d</code> is <span class="math inline">\(1\)</span>
then it is 0.</li>
</ul>
<p>We therefore conclude that no such function <code>h</code> can be
written in Haskell and so we cannot tell (in general) whether a term of
type <span class="math inline">\(\mathrm{Natural}\)</span> will diverge
or not. We should note that there is nothing special about <span
class="math inline">\(\mathrm{Natural}\)</span> in this argument and we
could have picked any type containing at least two distinct terms along
with some ability to compare terms for equality.</p>
<p>Thank you for reading! Hopefully this has demonstrated the unity of
ideas between the lambda calculus and a functional language like Haskell
and the naturality of studying computability theory from this
perspective. In the <a
href="https://boarders.github.io/posts/halting2.html">next post</a>, we
will formalise this argument in Agda.</p>
<p><i>With warmest thanks to Alixandra Prybyla and Sam Derbyshire for
their valuable feedback.</i></p>]]></content>
  </entry>
  <entry>
      <title>The Halting Problem (part 2)</title>
      <link href="https://boarders.github.ioposts/halting2.html"/>
      <id>https://boarders.github.ioposts/halting2.html</id>
      <updated>2020-12-07T00:00:SZ</updated>
      <category term="Halting Problem"/>
      <category term="Agda"/>
      <summary>Exploring the Halting problem in Agda</summary>
      <content type="html"><![CDATA[<p><a href="https://boarders.github.io/posts/halting1.html">Last
time</a>, we showed the undecidability of the halting problem using the
lambda calculus as our model of computation. In this post, we are going
to take that argument and formalise it in Agda. To begin, letâ€™s grab
some imports:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Halt <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>List</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(</span>List<span class="ot">;</span> []<span class="ot">;</span> <span class="ot">_</span>âˆ·<span class="ot">_)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Nullary</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">using</span> <span class="ot">(</span>Â¬<span class="ot">_)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Empty</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(</span>âŠ¥<span class="ot">;</span> âŠ¥-elim<span class="ot">)\</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Product</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(</span>Î£-syntax<span class="ot">;</span> <span class="ot">_</span>Ã—<span class="ot">_)</span> <span class="kw">renaming</span> <span class="ot">(_</span>,<span class="ot">_</span> <span class="kw">to</span> Sg<span class="ot">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>PropositionalEquality</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>â‰¡<span class="ot">_;</span> refl<span class="ot">)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Sum</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>âŠ<span class="ot">_;</span> injâ‚<span class="ot">;</span> injâ‚‚<span class="ot">)</span></span></code></pre></div>
<p>For this development we will use a typed lambda calculus essentially
identical to <a
href="https://en.wikipedia.org/wiki/Programming_Computable_Functions">PCF</a>
(only with booleans instead of natural numbers), as this makes the
formalisation quite tidy. In order to get the basic semantics of the
language we will closely follow the <a
href="https://plfa.github.io/DeBruijn/">DeBruijn</a> chapter from the
fantastic <a href="https://plfa.github.io/">Programming Language
Foundations in Agda</a>.</p>
<p>Our language will be simply-typed, having only booleans, <span
class="math inline">\(\mathbb{B}\)</span>, and function types:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Type <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  ğ”¹  <span class="ot">:</span>  Type</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>â‡’<span class="ot">_</span> <span class="ot">:</span> Type <span class="ot">â†’</span> Type <span class="ot">â†’</span> Type</span></code></pre></div>
<p>We make use of intrinsically well-scoped, well-typed terms and so we
use â€˜proof-carryingâ€™ de-bruijn indices for variables. In this set-up
indices act both as an index into a typing context and as a
<em>proof</em> that the variable is well-typed in the current
context.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- A typing context is represented as a list of types.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>Con <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Con <span class="ot">=</span> List Type</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- We use âˆ™ for the empty context.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>âˆ™ <span class="ot">:</span> Con</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>âˆ™ <span class="ot">=</span> []</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- _,_ extends contexts to the right as is typical in type theory</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- and so we use a view the list in reverse order.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="ot">_</span>,<span class="ot">_</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>,<span class="ot">_</span> <span class="ot">:</span> Con <span class="ot">â†’</span> Type <span class="ot">â†’</span> Con</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>,<span class="ot">_</span> con ty <span class="ot">=</span> ty âˆ· con</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- A type for de-bruijn indices into a context. The index represents</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- a pointer into a context along with a proof that the</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- context contains the given type at that position.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- For example, given the context:</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">--   Î“ = ğ”¹, ğ”¹ â‡’ ğ”¹</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- we have:</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">--    z   : ğ”¹ â‡’ ğ”¹ âˆˆ Î“</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">--    s z : ğ”¹ âˆˆ Î“</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>âˆˆ<span class="ot">_</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="ot">_</span>âˆˆ<span class="ot">_</span>  <span class="ot">(</span>t <span class="ot">:</span> Type<span class="ot">)</span> <span class="ot">:</span> Con <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>ts<span class="ot">}</span> <span class="ot">â†’</span> t âˆˆ <span class="ot">(</span>t âˆ· ts<span class="ot">)</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>r<span class="ot">}</span> <span class="ot">{</span>ts<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>t âˆˆ ts<span class="ot">)</span> <span class="ot">â†’</span> t âˆˆ <span class="ot">(</span>r âˆ· ts<span class="ot">)</span></span></code></pre></div>
<p>We can now define the terms of our language. Here
<code>Expr Î“ ty</code> denotes a term of type <code>ty</code> in the
typing context <code>Î“</code>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Expr <span class="ot">(</span>Î“ <span class="ot">:</span> Con<span class="ot">)</span> <span class="ot">:</span> Type <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  var  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a <span class="ot">:</span> Type<span class="ot">}</span> <span class="ot">â†’</span> a âˆˆ Î“ <span class="ot">â†’</span> Expr Î“ a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  app  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ <span class="ot">(</span>a â‡’ b<span class="ot">)</span> <span class="ot">â†’</span> Expr Î“ a <span class="ot">â†’</span> Expr Î“ b</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  lam  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">â†’</span> Expr <span class="ot">(</span>Î“, a<span class="ot">)</span> b <span class="ot">â†’</span> Expr Î“ <span class="ot">(</span>a â‡’ b<span class="ot">)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  tt   <span class="ot">:</span> Expr Î“ ğ”¹</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  ff   <span class="ot">:</span> Expr Î“ ğ”¹</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  bool <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ğ”¹ <span class="ot">â†’</span> Expr Î“ a <span class="ot">â†’</span> Expr Î“ a <span class="ot">â†’</span> Expr Î“ a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  fix  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">â†’</span> Expr <span class="ot">(</span>Î“ , a<span class="ot">)</span> a <span class="ot">â†’</span> Expr Î“ a</span></code></pre></div>
<p>The names are largely self-explanatory but we observe that we use
<code>bool</code> for the conditional instead of <code>if</code>. It is
also worth noting that as <code>lam</code> and <code>fix</code> are
binding forms, they take arguments with contexts extended by the type of
the bound variable.</p>
<p>We give an identical approach to variable substitution as in <a
href="https://plfa.github.io/">PLFA</a> by first defining context
extension and variable renaming:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ext <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ Î” <span class="ot">:</span> Con<span class="ot">}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty <span class="ot">:</span> Type<span class="ot">}</span> <span class="ot">â†’</span> ty âˆˆ Î“ <span class="ot">â†’</span> ty âˆˆ Î”<span class="ot">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty tyB <span class="ot">:</span> Type<span class="ot">}</span> <span class="ot">â†’</span> ty âˆˆ Î“ , tyB <span class="ot">â†’</span> ty âˆˆ Î” , tyB<span class="ot">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>ext Ï z <span class="ot">=</span> z             <span class="co">-- if it is the newly bound variable</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                        <span class="co">-- we simply return it.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>ext Ï <span class="ot">(</span>s x<span class="ot">)</span> <span class="ot">=</span> s <span class="ot">(</span>Ï x<span class="ot">)</span>   <span class="co">-- otherwise we perform the substitution</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                        <span class="co">-- and take successor.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- rename is defined by structural recursion, extending the renaming</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- at binding sites and applying it to variables.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>rename <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ Î”<span class="ot">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> ty âˆˆ Î“ <span class="ot">â†’</span> ty âˆˆ Î”<span class="ot">)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty <span class="ot">â†’</span> Expr Î” ty<span class="ot">)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>rename Ï <span class="ot">(</span>var x<span class="ot">)</span> <span class="ot">=</span> var <span class="ot">(</span>Ï x<span class="ot">)</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>rename Ï <span class="ot">(</span>app rator rand<span class="ot">)</span> <span class="ot">=</span> app <span class="ot">(</span>rename Ï rator<span class="ot">)</span> <span class="ot">(</span>rename Ï rand<span class="ot">)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>rename Ï <span class="ot">(</span>lam body<span class="ot">)</span> <span class="ot">=</span> lam <span class="ot">(</span>rename <span class="ot">(</span>ext Ï<span class="ot">)</span> body<span class="ot">)</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>rename Ï tt <span class="ot">=</span> tt</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>rename Ï ff <span class="ot">=</span> ff</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>rename Ï <span class="ot">(</span>bool b th el<span class="ot">)</span> <span class="ot">=</span> bool <span class="ot">(</span>rename Ï b<span class="ot">)</span> <span class="ot">(</span>rename Ï th<span class="ot">)</span> <span class="ot">(</span>rename Ï el<span class="ot">)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>rename Ï <span class="ot">(</span>fix body<span class="ot">)</span> <span class="ot">=</span> fix <span class="ot">(</span>rename <span class="ot">(</span>ext Ï<span class="ot">)</span> body<span class="ot">)</span></span></code></pre></div>
<p>Here, a variable renaming, <code>(âˆ€ {ty} â†’ ty âˆˆ Î“ â†’ ty âˆˆ Î”)</code>,
simply takes an index into one context of a particular type and gives an
index into a different context of the same type.</p>
<p>We extend this from variable renaming to arbitrary context
morphisms:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- extend a context morphism with a new bound variable.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>exts <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ Î”<span class="ot">}</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span>  ty âˆˆ Î“ <span class="ot">â†’</span> Expr Î” ty<span class="ot">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty tyB<span class="ot">}</span> <span class="ot">â†’</span> ty âˆˆ <span class="ot">(</span>Î“ , tyB<span class="ot">)</span> <span class="ot">â†’</span> Expr <span class="ot">(</span>Î” , tyB<span class="ot">)</span> ty<span class="ot">)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>exts Ï z     <span class="ot">=</span> var z</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>exts Ï <span class="ot">(</span>s x<span class="ot">)</span> <span class="ot">=</span> rename s <span class="ot">(</span>Ï x<span class="ot">)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Perform structural recursion, extending the context morphism at</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- binding sites and applying it to variables.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>subst <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ Î”<span class="ot">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> ty âˆˆ Î“ <span class="ot">â†’</span> Expr Î” ty<span class="ot">)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty <span class="ot">â†’</span> Expr Î” ty<span class="ot">)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>subst Ï <span class="ot">(</span>var x<span class="ot">)</span> <span class="ot">=</span> Ï x</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>subst Ï <span class="ot">(</span>app rator rand<span class="ot">)</span> <span class="ot">=</span> app <span class="ot">(</span>subst Ï rator<span class="ot">)</span> <span class="ot">(</span>subst Ï rand<span class="ot">)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>subst Ï <span class="ot">(</span>lam body<span class="ot">)</span> <span class="ot">=</span> lam <span class="ot">(</span>subst <span class="ot">(</span>exts Ï<span class="ot">)</span> body<span class="ot">)</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>subst Ï tt <span class="ot">=</span> tt</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>subst Ï ff <span class="ot">=</span> ff</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>subst Ï <span class="ot">(</span>bool b th el<span class="ot">)</span> <span class="ot">=</span> bool <span class="ot">(</span>subst Ï b<span class="ot">)</span> <span class="ot">(</span>subst Ï th<span class="ot">)</span> <span class="ot">(</span>subst Ï el<span class="ot">)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>subst Ï <span class="ot">(</span>fix body<span class="ot">)</span> <span class="ot">=</span> fix <span class="ot">(</span>subst <span class="ot">(</span>exts Ï<span class="ot">)</span> body<span class="ot">)</span></span></code></pre></div>
<p>This gives parallel substitution across an entire context
<code>Î“</code> to another context <code>Î”</code>. Intuitively we take an
open term with variables of type <code>Î“</code> and replace them with
terms of type <code>Î”</code>. To make this clearer let us give an
example:</p>
<pre><code>-- Our example context has three ğ”¹ variables. 
conâ‚ : Con
conâ‚ = âˆ™ , ğ”¹ , ğ”¹ , ğ”¹

-- Our open term is then, roughly, &quot;if x then y else z&quot; where
-- x : ğ”¹, y : ğ”¹ and z : ğ”¹
termâ‚ : Expr conâ‚ ğ”¹
termâ‚ = bool (var z) (var (s z)) (var (s (s z)))

-- For those variables we can then substitute closed terms:
subâ‚ : âˆ€ {ty} â†’ ty âˆˆ conâ‚ â†’ Expr âˆ™ ty
subâ‚ z = tt
subâ‚ (s z) = ff
subâ‚ (s (s z)) = tt

-- Our parallel substitution then works as expected:
subst-termâ‚ : subst subâ‚ termâ‚ â‰¡ bool tt ff tt
subst-termâ‚ = refl</code></pre>
<p>From parallel substitution, it is easy for us to define ordinary
substitution of a single binding variable. We define the context
morphism that decrements all variables in <span
class="math inline">\(\Gamma\)</span> and returns the substituting term
for the initial variable:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty tyB<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ tyB <span class="ot">â†’</span> ty âˆˆ <span class="ot">(</span>Î“ , tyB<span class="ot">)</span> <span class="ot">â†’</span> Expr Î“ ty</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sub term z   <span class="ot">=</span> term</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">_</span> <span class="ot">(</span>s pf<span class="ot">)</span> <span class="ot">=</span> var pf</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty tyB<span class="ot">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">â†’</span> Expr <span class="ot">(</span>Î“ , tyB<span class="ot">)</span> ty</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="ot">â†’</span> Expr Î“ tyB</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="ot">â†’</span> Expr Î“ ty</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>[<span class="ot">_</span>] <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">{</span>tyB<span class="ot">}</span> body term <span class="ot">=</span> subst <span class="ot">{</span>Î“ , tyB<span class="ot">}</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">(</span>sub term<span class="ot">)</span> body</span></code></pre></div>
<p>Again, letâ€™s give a simple example:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This time our context has n : ğ”¹ â‡’ ğ”¹ and b : ğ”¹</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>conâ‚‚  <span class="ot">:</span> Con</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>conâ‚‚  <span class="ot">=</span> âˆ™ , ğ”¹ â‡’ ğ”¹ , ğ”¹</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Our open term is n applied to b:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>termâ‚‚  <span class="ot">:</span> Expr conâ‚‚ ğ”¹</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>termâ‚‚  <span class="ot">=</span> app <span class="ot">(</span>var <span class="ot">(</span>s z<span class="ot">))</span> <span class="ot">(</span>var z<span class="ot">)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Once we substitute b â†¦ tt we have the smaller typing</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- context: </span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">--   âˆ™ , ğ”¹ â‡’ ğ”¹ </span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- and so we decrement the n variable.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>subst-termâ‚‚ <span class="ot">:</span> termâ‚‚ [ tt ] â‰¡ app <span class="ot">(</span>var z<span class="ot">)</span> tt</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>subst-termâ‚‚ <span class="ot">=</span> refl</span></code></pre></div>
<p>Next we can define the values of our language - that is, those terms
which terminating programs return. Along with values we define the
small-step operational semantics of the language, showing how reduction
takes place:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Value <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- lambdas are values</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  V-â†¦ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ <span class="ot">}</span> <span class="ot">{</span>ty tyB<span class="ot">}</span> <span class="ot">{</span>body <span class="ot">:</span> Expr <span class="ot">(</span>Î“ , tyB<span class="ot">)</span> ty<span class="ot">}</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> Value <span class="ot">(</span>lam body<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- tt is a value</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  V-tt <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">â†’</span> Value <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> tt</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- ff is a value</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  V-ff <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">â†’</span> Value <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> ff</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="ot">_</span>â†“<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty <span class="ot">-&gt;</span> Expr Î“ ty <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- reduce on the left in an application.</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  l-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty tyB<span class="ot">}</span> <span class="ot">{</span>L L&#39; <span class="ot">:</span> Expr Î“ <span class="ot">(</span>ty â‡’ tyB<span class="ot">)}</span> <span class="ot">{</span>R <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> L â†“ L&#39;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> app L R â†“ app L&#39; R</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- reduce on the right so long as we have already reduced the left</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- argument to a value.</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  r-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty tyB<span class="ot">}</span> <span class="ot">{</span>VL <span class="ot">:</span> Expr Î“ <span class="ot">(</span>ty â‡’ tyB<span class="ot">)}</span> <span class="ot">{</span> R R&#39; <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="ot">(</span>Value VL<span class="ot">)</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> R â†“ R&#39;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> app VL R â†“ app VL R&#39;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Perform beta-reduction.</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  Î²-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty tyB<span class="ot">}</span> <span class="ot">{</span>N <span class="ot">:</span> Expr <span class="ot">(</span>Î“ , tyB<span class="ot">)</span> ty<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Expr Î“ tyB<span class="ot">}</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="ot">(</span>app <span class="ot">(</span>lam N<span class="ot">)</span> V<span class="ot">)</span> â†“ <span class="ot">(</span>N [ V ]<span class="ot">)</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- reduce boolean in a conditional.</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  if-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">{</span>b b&#39; <span class="ot">:</span> Expr Î“ ğ”¹<span class="ot">}</span> <span class="ot">{</span>th el <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> b â†“ b&#39;</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="ot">(</span>bool b th el<span class="ot">)</span> â†“ <span class="ot">(</span>bool b&#39; th el<span class="ot">)</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- reduce conditional to true branch.</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>  if-tt-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">{</span>th el <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="ot">(</span>bool tt th el<span class="ot">)</span> â†“ th</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co">-- reduce conditional to false branch.</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  if-ff-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> <span class="ot">{</span>th el <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="ot">(</span>bool ff th el<span class="ot">)</span> â†“ el</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- recursively substitute fix expression.</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  fix-â†“ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">{</span>expr <span class="ot">:</span> Expr <span class="ot">(</span>Î“ , ty<span class="ot">)</span> ty<span class="ot">}</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> fix expr â†“ <span class="ot">(</span>expr [ fix expr ]<span class="ot">)</span></span></code></pre></div>
<p>We use (something close to) a call-by-name semantics and so donâ€™t
necessarily reduce arguments to values before performing <span
class="math inline">\(\beta\)</span>-reduction. We also fix a leftmost
evaluation order for applications reducing the left argument to a value
before the right argument. We extend this relation to its reflective,
transitive closure - the stepping relation - that one expression
reduces, in some number of steps, to another.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="ot">_</span>â‡“<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty <span class="ot">â†’</span> Expr Î“ ty <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- reflexivity</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>âˆ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">(</span>M <span class="ot">:</span> Expr Î“ ty<span class="ot">)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> M â‡“ M</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- transitivity</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>â†’âŸ¨<span class="ot">_</span>âŸ©<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">(</span>L <span class="ot">:</span> Expr Î“ ty<span class="ot">)</span> <span class="ot">{</span>M N <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> L â†“ M</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> M â‡“ N</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> L â‡“ N</span></code></pre></div>
<p>For later use we note, as one might expect, that values, as we have
defined them, only reduce to themselves:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>â‡“-val <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ a<span class="ot">}</span> <span class="ot">{</span>e e&#39; <span class="ot">:</span> Expr Î“ a<span class="ot">}</span> <span class="ot">â†’</span> Value e <span class="ot">â†’</span> e â‡“ e&#39; <span class="ot">â†’</span> e&#39; â‰¡ e</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>â‡“-val val   <span class="ot">(_</span> âˆ<span class="ot">)</span> <span class="ot">=</span> refl</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- In the cases where we have a transitive step Agda will</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- produce an absurd pattern as none of the reduction</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- rules apply.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>â‡“-val V-â†¦  <span class="ot">(_</span> â†’âŸ¨ <span class="ot">()</span> âŸ© st<span class="ot">)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>â‡“-val V-tt <span class="ot">(_</span> â†’âŸ¨ <span class="ot">()</span> âŸ© st<span class="ot">)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>â‡“-val V-ff <span class="ot">(_</span> â†’âŸ¨ <span class="ot">()</span> âŸ© st<span class="ot">)</span></span></code></pre></div>
<p>Now let us think about our <span
class="math inline">\(\mathbf{HALT}\)</span> term from last time. We
define the notion of halting by stating the existence of both a value
and a series of reduction steps to that value. We encode that as
follows:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Halt <span class="ot">{</span>Î“ a<span class="ot">}</span> <span class="ot">(</span>e <span class="ot">:</span>  Expr Î“ a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  halts <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>v <span class="ot">:</span> Expr Î“ a<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>Value v<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>e â‡“ v<span class="ot">)</span> <span class="ot">â†’</span> Halt e</span></code></pre></div>
<p>We are now in the position to postulate the existence of a
<code>halt</code> function with the expected properties:</p>
<pre><code>postulate
  halt     : âˆ€ {Î“} {a} â†’ Expr Î“ (a â‡’ ğ”¹)
-- halt is a closed term
  halt-sub :
    âˆ€ {Î“ Î”} {a}
    â†’ (Ï : âˆ€ {ty} â†’ ty âˆˆ Î“ â†’ Expr Î” ty)
    â†’ subst {Î“} {Î”} Ï (halt {Î“} {a}) â‰¡ halt {Î”}
  halt-ret :
    âˆ€ {Î“} {ty}
    (e : Expr Î“ ty) â†’ app halt e â‡“ tt âŠ app halt e â‡“ ff
  halt-tt  :
    âˆ€ {Î“ ty}
    (e : Expr Î“ ty) â†’ app halt e â‡“ tt â†’ Halt e
  halt-ff :
    âˆ€ {Î“ ty}
    (e : Expr Î“ ty) â†’ app halt e â‡“ ff â†’ Â¬ Halt e</code></pre>
<p>We assume we have a function <code>halt</code> that takes an argument
of any type (in the meta-language, agda, since our language doesnâ€™t
itself have polymorphism) and returns a bool. That this function applies
to terms of any type is irrelevant to the argument we give here. This
would work just as well were we to simply use <code>ğ”¹</code>.</p>
<p>We also assume that it is decidable that halt always returns
<code>tt</code> or <code>ff</code>. Furthermore, the terms
<code>halt-tt</code> and <code>halt-ff</code> encode our assumptions
regarding applying the <code>halt</code> function - if it returns
<code>tt</code>, then the term is normalizing and conversely, if it
returns <code>ff</code>, then it is non-normalizing.</p>
<p>We can now define our three terms from last time:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Since fix takes a binding term we write fix (var z)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- instead of the term fix (lam z) we used last time.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>bot <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>ty Î“<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ty</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>bot <span class="ot">=</span> fix <span class="ot">(</span>var z<span class="ot">)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>problem <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">â†’</span> Expr <span class="ot">(</span>Î“ , ğ”¹<span class="ot">)</span> ğ”¹</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>problem <span class="ot">=</span> bool <span class="ot">(</span>app halt <span class="ot">(</span>var z<span class="ot">))</span> bot tt</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>fix-problem <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">â†’</span> Expr Î“ ğ”¹</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>fix-problem <span class="ot">=</span> fix problem</span></code></pre></div>
<p>At this point we would like to use <code>halt-ret</code> on
<code>fix-problem</code> but upon reflection we see that last timeâ€™s
argument was a little loose. We showed that if
<code>halt fix-problem</code> is <code>true</code> then
<code>fix-problem</code> reduces to <code>bot</code> but this actually
isnâ€™t enough, by itself, to get a contradiction. What we need to know is
that if a term reduces to <code>bot</code> then no other reduction
sequence halts.</p>
<p>Stated as a general lemma:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>halt-âŠ¥ <span class="ot">:</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">{</span>e1 e2 <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> e1 â‡“ e2 <span class="ot">â†’</span> Â¬ <span class="ot">(</span>Halt e2<span class="ot">)</span> <span class="ot">â†’</span> Â¬ <span class="ot">(</span>Halt e1<span class="ot">)</span></span></code></pre></div>
<p>In order to prove this, we would like to use the following: if
<code>e1</code> steps to a value then there exists some reduction
sequence where <code>e2</code> also steps to that same value. This
follows from the more general property of confluence:</p>
<p><strong>Definition [Confluence]</strong>: A reduction relation <span
class="math inline">\(\rightarrow\)</span> on a set <span
class="math inline">\(\mathcal{T}\)</span> is confluent if for any <span
class="math inline">\(e1, e2, e3 \in \mathcal{T}\)</span> there exists
an <span class="math inline">\(e4\)</span> such that the following
diagram commutes: <span class="math display">\[
    \require{AMScd}
    \begin{CD}
    e1     @&gt;&gt;&gt;  e2\\
    @VVV        @VV*V\\
    e3     @&gt;*&gt;&gt;  e4
    \end{CD}
\]</span> Here <span class="math inline">\(\xrightarrow{*}\)</span>
denotes the reflective, transitive closure of <span
class="math inline">\(\rightarrow\)</span>.</p>
<p>It would be outside of the scope of this post to prove confluence but
it is a well-known result (and one which I will blog about in the
future) that the lambda calculus is confluent. As such, we allow
ourselves to assume it as a postulate:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">postulate</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  confluence</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">{</span>e e1 e2 <span class="ot">:</span> Expr Î“ a<span class="ot">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> e â‡“ e1 <span class="ot">â†’</span> e â‡“ e2</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> Î£[ e3 âˆˆ Expr Î“ a ] <span class="ot">(</span>e1 â‡“ e3<span class="ot">)</span> Ã— <span class="ot">(</span>e2 â‡“ e3<span class="ot">)</span></span></code></pre></div>
<p>In the above we make use of Agdaâ€™s sigma syntax. A term of the form
<code>Î£[ x âˆˆ A ] P</code> is a convenient syntax agda offers for the
dependent sum, traditionally written something like <span
class="math inline">\(\Sigma_{x \in A} P\)</span>. Using confluence, it
is now easy to prove that if a term halts at a value then no matter
which reduction steps we take to some other term we will still be able
to reduce to the same value:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>â‡“-val-uniq</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">{</span>e e&#39; v <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> Value v <span class="ot">â†’</span> e â‡“ v <span class="ot">â†’</span> e â‡“ e&#39; <span class="ot">â†’</span> e&#39; â‡“ v</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>â‡“-val-uniq pf eâ‡“v eâ‡“e&#39; <span class="kw">with</span> confluence eâ‡“v eâ‡“e&#39;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> Sg e3 <span class="ot">(</span>Sg vâ‡“e3 e&#39;â‡“e3<span class="ot">)</span> <span class="kw">with</span> â‡“-val pf vâ‡“e3</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> refl <span class="ot">=</span> e&#39;â‡“e3</span></code></pre></div>
<p>From this, we can conclude the â€œhead-expansionâ€ property we wanted of
non-termination:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>halt-âŠ¥</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">{</span>e1 e2 <span class="ot">:</span> Expr Î“ ty<span class="ot">}</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> e1 â‡“ e2 <span class="ot">â†’</span> Â¬ <span class="ot">(</span>Halt e2<span class="ot">)</span> <span class="ot">â†’</span> Â¬ <span class="ot">(</span>Halt e1<span class="ot">)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>halt-âŠ¥ e1â‡“e2 e2-âŠ¥ <span class="ot">(</span>halts v-e1 st<span class="ot">)</span> <span class="kw">with</span> â‡“-val-uniq v-e1 st e1â‡“e2</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> e2â‡“v <span class="ot">=</span> e2-âŠ¥ <span class="ot">(</span>halts v-e1 e2â‡“v<span class="ot">)</span></span></code></pre></div>
<p>First, it is easy for us to show (recursively) that <code>bot</code>
does not halt:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>bot-non-term <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">â†’</span>  Â¬ <span class="ot">(</span>Halt <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ty<span class="ot">}</span> bot<span class="ot">)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>bot-non-term <span class="ot">(</span>halts v <span class="ot">(.(</span>fix <span class="ot">(</span>var z<span class="ot">))</span> â†’âŸ¨ fix-â†“ âŸ© st<span class="ot">))</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> bot-non-term <span class="ot">(</span>halts v st<span class="ot">)</span></span></code></pre></div>
<p>We can then put together <code>halt-âŠ¥</code> and
<code>bot-non-term</code> to show that any term that steps to
<code>bot</code> cannot terminate:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>â‡“-bot-âŠ¥ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“ ty<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>e <span class="ot">:</span> Expr Î“ ty<span class="ot">)</span> <span class="ot">â†’</span> e â‡“ bot <span class="ot">â†’</span> Â¬ Halt e</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>â‡“-bot-âŠ¥ e st <span class="ot">=</span> halt-âŠ¥ st bot-non-term</span></code></pre></div>
<p>Now, we are better placed to show that if
<code>halt fix-problem</code> reduces to <code>tt</code> then
<code>fix-problem</code> reduces to <code>bot</code> and thus we get a
contradiction. The final general result we will need is one that
connects the big step operational semantics of Booleans to that of our
conditional function, <code>bool</code>.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- In both cases if there is no reduction then we directly step.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Otherwise we reduce the conditional and recurse on the result.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>bool-stepper-tt</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>th el<span class="ot">}</span> <span class="ot">(</span>b <span class="ot">:</span> Expr Î“ ğ”¹<span class="ot">)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> b â‡“ tt <span class="ot">â†’</span> <span class="ot">(</span>bool <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> b th el<span class="ot">)</span> â‡“ th</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>bool-stepper-tt <span class="ot">{_}</span> <span class="ot">{</span>th<span class="ot">}</span> <span class="ot">{</span>el<span class="ot">}</span> <span class="ot">.</span>tt <span class="ot">(.</span>tt âˆ<span class="ot">)</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> bool tt th el â†’âŸ¨ if-tt-â†“ âŸ© <span class="ot">(</span>th âˆ<span class="ot">)</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>bool-stepper-tt <span class="ot">{_}</span> <span class="ot">{</span>th<span class="ot">}</span> <span class="ot">{</span>el<span class="ot">}</span> b <span class="ot">(_</span>â†’âŸ¨<span class="ot">_</span>âŸ©<span class="ot">_</span> <span class="ot">.</span>b <span class="ot">{</span>M<span class="ot">}</span> x st<span class="ot">)</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="ot">_</span>â†’âŸ¨<span class="ot">_</span>âŸ©<span class="ot">_</span> <span class="ot">(</span>bool b th el<span class="ot">)</span> <span class="ot">(</span>if-â†“ x<span class="ot">)</span> <span class="ot">(</span>bool-stepper-tt M st<span class="ot">)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>bool-stepper-ff</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>th el<span class="ot">}</span> <span class="ot">(</span>b <span class="ot">:</span> Expr Î“ ğ”¹<span class="ot">)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> b â‡“ ff <span class="ot">â†’</span> <span class="ot">(</span>bool <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> b th el<span class="ot">)</span> â‡“ el</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>bool-stepper-ff <span class="ot">{_}</span> <span class="ot">{</span>th<span class="ot">}</span> <span class="ot">{</span>el<span class="ot">}</span> <span class="ot">.</span>ff <span class="ot">(.</span>ff âˆ<span class="ot">)</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> bool ff th el â†’âŸ¨ if-ff-â†“ âŸ© <span class="ot">(</span>el âˆ<span class="ot">)</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>bool-stepper-ff <span class="ot">{_}</span> <span class="ot">{</span>th<span class="ot">}</span> <span class="ot">{</span>el<span class="ot">}</span> b <span class="ot">(_</span>â†’âŸ¨<span class="ot">_</span>âŸ©<span class="ot">_</span> <span class="ot">.</span>b <span class="ot">{</span>M<span class="ot">}</span> x st<span class="ot">)</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="ot">_</span>â†’âŸ¨<span class="ot">_</span>âŸ©<span class="ot">_</span> <span class="ot">(</span>bool b th el<span class="ot">)</span> <span class="ot">(</span>if-â†“ x<span class="ot">)</span> <span class="ot">(</span>bool-stepper-ff M st<span class="ot">)</span></span></code></pre></div>
<p>We are now in a position to show that
<code>halt (fix-problem) â‡“ tt</code> gives rise to a contradiction which
we do in a number of simple steps:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- First, we show that there is only a single way to reduce</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- fix-problem since only the fix rule applies.</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- In order to reduce fix-problem to what we want</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- we have to know that:</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   problem [ fix-problem ] â‰¡ bool (app halt fix-problem) bot tt</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- In order for this to be the case we need that:</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">--     app (halt [ fix-problem ]) (sub fix-problem z)</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">--   â‰¡ app halt fix-problem</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- and so we need that halt is a closed term. That is precisely what</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- halt-sub gives us:</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>fp-step1</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>e <span class="ot">:</span> Expr Î“ ğ”¹<span class="ot">}</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>fix-problem <span class="ot">{</span>Î“<span class="ot">})</span> â†“ e</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> e â‰¡ bool <span class="ot">(</span>app halt fix-problem<span class="ot">)</span> bot tt</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>fp-step1 <span class="ot">{</span>Î“<span class="ot">}</span> fix-â†“</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> <span class="ot">(</span>halt-sub <span class="ot">{</span>Î“ , ğ”¹<span class="ot">}</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> <span class="ot">(</span>sub <span class="ot">{</span>Î“<span class="ot">}</span> fix-problem<span class="ot">))</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> refl</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Here we have a small lemma that we can replace</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- equal values in the stepping relation</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>â‰¡-â†“</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>e e&#39; e&#39;&#39; <span class="ot">:</span> Expr Î“ ğ”¹<span class="ot">}</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> e â†“ e&#39;</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> e&#39; â‰¡ e&#39;&#39;</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> e â†“ e&#39;&#39;</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>â‰¡-â†“ eâ†“e&#39; refl <span class="ot">=</span> eâ†“e&#39;</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- We then make use of this fact and step 1 to show</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- that fix-problem steps as we expect:</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>fp-step2</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>fix-problem <span class="ot">{</span>Î“<span class="ot">})</span> â†“ <span class="ot">(</span>bool <span class="ot">(</span>app halt <span class="ot">(</span>fix-problem<span class="ot">))</span> bot tt<span class="ot">)</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>fp-step2 <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>  â‰¡-â†“ <span class="ot">(</span>fix-â†“ <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> <span class="ot">{</span>problem<span class="ot">})</span> <span class="ot">(</span>fp-step1 <span class="ot">(</span>fix-â†“ <span class="ot">{</span>Î“<span class="ot">}</span> <span class="ot">{</span>ğ”¹<span class="ot">}</span> <span class="ot">{</span>problem<span class="ot">}))</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a><span class="co">-- In the next two steps we then use our assumption and the</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a><span class="co">-- big step lemma to derive a contradiction:</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>fp-step3</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ tt</span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>bool <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> bot tt<span class="ot">)</span> â‡“ bot</span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>fp-step3 â‡“-tt <span class="ot">=</span> bool-stepper-tt <span class="ot">_</span>  â‡“-tt</span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>fp-step4</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ tt</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>fix-problem <span class="ot">{</span>Î“<span class="ot">})</span> â‡“ bot</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>fp-step4 <span class="ot">{</span>Î“<span class="ot">}</span> â‡“-tt <span class="ot">=</span> fix-problem â†’âŸ¨ fp-step2 âŸ© fp-step3 â‡“-tt</span></code></pre></div>
<p>The other half of the argument, assuming
<code>halt (fix-problem) â‡“ ff</code>, is quite a bit simpler. To prove
halting, we only need to exhibit some particular sequence of
reductions:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fp-step5</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ ff</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>bool <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> bot tt<span class="ot">)</span> â‡“ tt</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>fp-step5 â‡“-ff <span class="ot">=</span> bool-stepper-ff <span class="ot">_</span> â‡“-ff</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- We make use of our substition lemma (fp-step2) to</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- show under this assumption that fix-problem big</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- steps to tt.</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>fp-step6</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ ff</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>   <span class="ot">â†’</span> fix-problem â‡“ tt</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>fp-step6 â‡“-ff <span class="ot">=</span> fix-problem â†’âŸ¨ fp-step2 âŸ© fp-step5 â‡“-ff</span></code></pre></div>
<p>Finally, letâ€™s package up these results into their respective
contradictions:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>fix-problem-tt</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ tt</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> Halt <span class="ot">{</span>Î“<span class="ot">}</span> fix-problem <span class="ot">â†’</span> âŠ¥</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>fix-problem-tt â‡“-tt h <span class="ot">=</span> â‡“-bot-âŠ¥ <span class="ot">_</span> <span class="ot">(</span>fp-step4 â‡“-tt<span class="ot">)</span> h</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>fix-problem-ff</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>Î“<span class="ot">}</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>app <span class="ot">(</span>halt <span class="ot">{</span>Î“<span class="ot">})</span> fix-problem<span class="ot">)</span> â‡“ ff</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>Â¬ Halt <span class="ot">{</span>Î“<span class="ot">}</span> fix-problem<span class="ot">)</span> <span class="ot">â†’</span> âŠ¥</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>fix-problem-ff â‡“-ff Â¬h <span class="ot">=</span> Â¬h <span class="ot">(</span>halts V-tt <span class="ot">(</span>fp-step6 â‡“-ff<span class="ot">))</span></span></code></pre></div>
<p>and put everything together:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>halting <span class="ot">:</span> âŠ¥</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>halting <span class="kw">with</span> halt-ret <span class="ot">{</span>nil<span class="ot">}</span> fix-problem</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>halting <span class="ot">|</span> injâ‚ â‡“tt  <span class="ot">=</span> fix-problem-tt â‡“tt <span class="ot">(</span>halt-tt fix-problem â‡“tt<span class="ot">)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>halting <span class="ot">|</span> injâ‚‚ â‡“ff  <span class="ot">=</span> fix-problem-ff â‡“ff <span class="ot">(</span>halt-ff fix-problem â‡“ff<span class="ot">)</span></span></code></pre></div>
<p>Hopefully this post has given an approachable account of formalising
one of the central results in computability theory. We hope to have also
demonstrated, from a programming language theory perspective, some of
the advantages of the lambda calculus as a foundational theory of
computation (over, for example, Turing machines). Thank you for reading!
The full code for this proof is available <a
href="https://github.com/Boarders/agda-halting">here</a>.</p>
<p><i>With warmest thanks to Alixandra Prybyla and Sam Derbyshire for
their valuable feedback.</i></p>]]></content>
  </entry>
  <entry>
      <title>Locally Nameless</title>
      <link href="https://boarders.github.ioposts/locally-nameless.html"/>
      <id>https://boarders.github.ioposts/locally-nameless.html</id>
      <updated>2019-10-27T00:00:SZ</updated>
      <category term="Type theory"/>
      <category term="Lambda Calculus"/>
      <summary>The locally nameless approach to substitution.</summary>
      <content type="html"><![CDATA[<p>The untyped lambda calculus has a very simple grammar with just three
term formers: <span
class="math inline">\(\def\sp{\mspace{5mu}}\)</span></p>
<p><span class="math display">\[ \mathrm{term}
\mathrel{\vcenter{\hbox{::}}{=}} v \sp
  | \sp \lambda \sp v \sp . \sp \mathrm{term} \sp
  | \sp \mathrm{term} \sp \mathrm{term} \sp
  \]</span></p>
<p>Or in Haskell:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lam</span> a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span></code></pre></div>
<p>In order that this work as a theory of computation, we need some
notion of evaluation and this is driven by <span
class="math inline">\(\beta\)</span>-reduction. The standard jargon in
lambda caluclus is to say that a <span
class="math inline">\(\beta\)</span>-redex is any subterm of the form
<span class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f})
\sp \mathrm{arg}\)</span>. On such a <span
class="math inline">\(\beta\)</span>-redex we can then step via
(capture-avoiding) substitution:</p>
<p><span class="math display">\[ (\lambda \mathrm{x} \sp . \sp
\mathrm{f}) \sp \mathrm{arg}
    \rightsquigarrow
   f\sp[x  \mathrel{\vcenter{\hbox{:}}{=}} \mathrm{arg}]
  \]</span></p>
<p>Formally we then extend this to a congruence relation on Lambda terms
via rules of the form:</p>
<p><span class="math display">\[
  M \rightsquigarrow M&#39; \Rightarrow M N \rightsquigarrow M&#39; N
\]</span> <span class="math display">\[
  N \rightsquigarrow N&#39; \Rightarrow M N \rightsquigarrow M  N&#39;
  \]</span></p>
<p>Precisely how we choose to set up these rules to give a computational
semantics to our language corresponds algorithmically to a choice of
evaluation strategy. As such, this opens up myriad interesting questions
related to order of evaluation and normal forms and so on. Instead we
will largely bypass these considerations and concentrate on the more
humdrum (but no less vital) matter of the practicalities of performing
such capture-avoiding substitutions. The basic problem with too naive an
approach is as follows:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp
\lambda \sp y \sp . \sp  x) \sp \mathrm{y}
    \rightsquigarrow
   (\lambda \mathrm{y} \sp . \sp y)
  \]</span></p>
<p>Here we have substituted the <em>free</em> variable y into our lambda
term and it has become <em>bound</em>. This is semantically incorrect:
the names of free variables are meaningful because, in spirit, they
refer to names we have defined elsewhere (that is, they can be looked up
within a context, or, in other words, they are <em>open</em> for further
substitution). Conversely, the names of bound variables are,
computationally speaking, unimportant. In fact, it is usual to refer to
the grammar we have introduced earlier as <em>pre-lambda terms</em> and
to take lambda terms as referring to the equivalence classes under <span
class="math inline">\(\alpha\)</span>-equivalence. This refers to the
(equivalence) relation whereby two terms are equivalent if we can
consistently rename the bound variables of one to obtain the other (here
too we need to take care, <span
class="math inline">\(\alpha\)</span>-renaming <span
class="math inline">\(\mathrm{x}\)</span> to <span
class="math inline">\(\mathrm{y}\)</span> in the above term would lead
to a different sort of variable capture). Most accounts of <span
class="math inline">\(\alpha\)</span>-equivalence are themselves
intimiately tied up with the question of how to perform substitution
(and locally nameless is no different in this respect).</p>
<p>In practice this means that in order to compute <span
class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp
\mathrm{arg}\)</span> we would first <span
class="math inline">\(\alpha\)</span>-rename <span
class="math inline">\(\mathrm{x}\)</span> to a variable that is neither
already named within <span class="math inline">\(\mathrm{f}\)</span>,
nor appears free within <span
class="math inline">\(\mathrm{arg}\)</span>. Carrying out such a
procedure by brute force is workable, but tends to be rather
error-prone. A straightforward approach along these lines is described
in <a
href="http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html">this
excellent post</a> by Lennart Augustsson.</p>
<p>There are a <a
href="https://www.schoolofhaskell.com/user/edwardk/bound">whole host</a>
of more sophisticated methods for dealing with the problem of
capture-avoiding substitution. Perhaps one of the best known is to use
De-Bruijn indices. The idea here is to replace all bound variables by a
natural number. This indicates the variableâ€™s distance from its binding
site. All free variables are then represented by distinct natural
numbers greater than the maximum depth of any binding site in the term.
We then keep track of these variables within the environment under which
computation is performed. For instance, the following is how one might
translate a typical term into De-Bruijn indices:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp
\lambda \sp y \sp . \sp  x \sp z)
    \longrightarrow
   (\lambda \sp \lambda \sp . \sp 1 \sp 3 )
   \]</span> <span class="math display">\[
   [z \mapsto 3]
  \]</span></p>
<p>Here we keep both the translated lambda term but also the context for
how to read free variables.</p>
<p>This approach offers two key advantages:</p>
<ul>
<li>Capture avoiding substitution becomes a matter of keeping binding
distance arithmetic in check.</li>
<li>The De-Bruijn representation gives canonical representatives for
<span class="math inline">\(\alpha\)</span>-equivalence classes, thus
allowing us to test for <span
class="math inline">\(\alpha\)</span>-equivalence via syntactic equality
of terms.</li>
</ul>
<p>On the other hand, Bob Atkey has, rather aptly, referred to the
ability to read terms written with DeBruijn indices as a â€œcylon
detectorâ€. What we gain in ease of implementation we give up in much
worse readability.</p>
<p>Instead we turn to the hybrid approach in the paper <a
href="http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">I Am Not a
Number â€“ I am a Free Variable</a>. Let us keep free variables free and
use De-Bruijn indices only for bound variables:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Our variable type keeps the old free variables and uses</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">--integers to represent bound variables.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Var</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">F</span> a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">B</span> <span class="dt">Int</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Locally nameless terms will be the same lambda terms with</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- variables now labelled either bound or free.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LocallyNameless</span> a <span class="ot">=</span> <span class="dt">Lam</span> (<span class="dt">Var</span> a)</span></code></pre></div>
<p>Notice how, because we use the same lambda terms with this
representation, we still have names at binders. This is useful as we can
recover the named term we started out with, carrying along all such
names as we perform work. Here is how we convert between the two
representations:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase          #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">toLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>toLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Var</span> a  <span class="ot">-&gt;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- we check if our variable has been bound elsewhere</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> a <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> bv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> a)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- As we have gone under a binder we bump each variable</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- by 1, inserting our newly bound variable at 0.</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>          env&#39; <span class="ot">=</span> insert n <span class="dv">0</span> (M.map (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Lam</span> (<span class="dt">F</span> n) (go env&#39; e)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>fromLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Map</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Var</span> v <span class="ot">-&gt;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> v <span class="kw">of</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>          <span class="dt">F</span> a  <span class="ot">-&gt;</span> <span class="dt">Var</span> a</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>               <span class="co">-- we look up our bound variable with the name we collected from</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>               <span class="co">-- its binder</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="kw">case</span> bv <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> name</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;Found bound variable :&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv <span class="op">&lt;&gt;</span> <span class="st">&quot; without binder.&quot;</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- if our lambda term has a Bound variable at a binding site something</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- has gone horribly wrong</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Found unnamed variable at binding site&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>          <span class="dt">F</span> v  <span class="ot">-&gt;</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>           <span class="co">-- We store the name of the binder in the environment</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>              env&#39; <span class="ot">=</span> insert <span class="dv">0</span> v (mapKeysMonotonic (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Lam</span> v (go env&#39; e)</span></code></pre></div>
<p>Now letâ€™s see that this works as expected (this is, for me, a
worrying amount of bookeeping to leave to â€œLooks good!â€). Let us use
quickcheck to see that <strong>fromLocallyNameless</strong> is a left
inverse to <strong>toLocallyNameless</strong>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- We use a somewhat unprincipled approach to generating arbitrary terms</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- but for our purposes it will do the job.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Lam</span> a) <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>      buildTerm i</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">      buildTerm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Term</span> a)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      buildTerm i</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">2</span>    <span class="ot">=</span> arbitrary <span class="op">&gt;&gt;=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">Var</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">8</span>    <span class="ot">=</span> <span class="dt">Lam</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- so that our terms don&#39;t explode we limit</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- the amount of branching we allow</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">App</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- fromLocalyNameless is a left inverse to toLocallyNameless.</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLocallyNamelessLeftInverse ::</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>fromLocallyNamelessLeftInverse e <span class="ot">=</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  (fromLocallyNameless <span class="op">.</span> toLocallyNameless) e <span class="op">===</span> e</span></code></pre></div>
<p>Thankfully, this does indeed work as expected:</p>
<pre class="shell"><code>Tests
  Property Tests
    fromLocallyNameless âˆ˜ toLocallyNameless == id: OK (0.35s)
      +++ OK, passed 1000 tests.</code></pre>
<p>Now that we have terms in locally nameless representation, we can
perform substitution in a fairly straightforward manner. In the
McBrideâ€“McKinna (MM) paper, they refer to this operation as
<strong>â€œinstantiateâ€</strong>. It is also common in the locally
nameless literature to call the operation <strong>â€œopeningâ€</strong> or
<strong>â€œopenâ€</strong> because it involves opening the body of a term
to substitute for its outermost bound variable. As this accords with our
intuitions on the meaning of substitution of locally nameless terms, we
will follow this convention.</p>
<p>Note that in the code below, we follow (at least in spirit) the MM
approach of using a scope type to denote a term that is only legal as
the body of an expression (i.e.Â a term which may have bound variables
referring to a non-existant outer binder such as <span
class="math inline">\(\lambda \sp . \sp 1\)</span>). In our case, we
only use a type synonym; however, in a more substantial implementation,
one should use a newtype to get the type safety that such a measure
confers.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Scope</span> f x <span class="ot">=</span> f x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- â”Œâ”€â”€â”€ term we are substituting</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- â”‚</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- â”‚                 â”Œâ”€â”€â”€ body we are substituting into</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- â”‚                 â”‚</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- â”‚                 â”‚</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">open ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Scope</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>open image <span class="ot">=</span> go <span class="dv">0</span> <span class="co">-- the bound variable begins at 0</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    go outer <span class="ot">=</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      \<span class="kw">case</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Var</span> fbv <span class="ot">-&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> fbv <span class="kw">of</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- if the bound variable refers to the outer binder of the body</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- of the term then we substitute the image.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">B</span> bv <span class="op">|</span> bv <span class="op">==</span> outer <span class="ot">-&gt;</span> image</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">F</span> fv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> fv)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go outer l) (go outer r)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- Note that as we have gone under another binder we must</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- in turn bump the binding variable we substitute for</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- so that it still refers to the outermost binder.</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Lam</span> n b <span class="ot">-&gt;</span> <span class="dt">Lam</span> n (go (outer <span class="op">+</span> <span class="dv">1</span>) b)</span></code></pre></div>
<p>From here it is easy for us to implement reduction to both normal
form and weak-head normal form (where we use call-by-name semantics). We
will, in both cases, write a function that does all of the work using
locally nameless terms and functions that make use of that work on named
lambda terms via the previously defined conversion functions:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">whnfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>whnfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- â”Œâ”€â”€â”€ current leftmost lambda term</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- â”‚</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- â”‚             â”Œâ”€â”€â”€ list of collected arguments</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- â”‚             â”‚</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- â”‚             â”‚</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- if we encounter an application then we collect the</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- argument on the right and recurse into the left term</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- We only perform substitution if we have both</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- a non-empty list of arguments to substitute and</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- a leftmost lambda term.</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Note that we substitute the body before evaluation</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- and hence we follow call-by-name semantics.</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        _</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- otherwise we encountered no further leftmost</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- lambda terms and so we re-apply App to the</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- built-up list of arguments</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t as</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="ot">whnf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- defer the work to the locally nameless terms</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>whnf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> whnfLN <span class="op">.</span> toLocallyNameless</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="ot">nfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>nfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- the same as above we collect right arguments in a list.</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- If we have no arguments to apply to a lambda then we</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- recurse into the body (this is the difference between</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- normal form and weak head normal form).</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> n body) , [])</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> (<span class="dt">Lam</span> n (nfLN body))</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        _</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- If we encounter no further lambdas then we reduce </span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- each of our built-up arguments before re-applying App.</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t (<span class="fu">fmap</span> nfLN as)</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a><span class="ot">nf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- again we defer all the actual work to locally nameless terms.</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>nf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> nfLN <span class="op">.</span> toLocallyNameless</span></code></pre></div>
<p>Now that we have written this reduction code, we should test it. But
what on? A natural choice is to consider church encodings of the natural
numbers. Since all we have in the lambda calculus is a theory of
functions (with no base data types), we must encode any data in the form
of functions. Church numerals act as a prototypical example of such an
encoding:</p>
<p><span class="math display">\[ \mathrm{zero} = \lambda \sp \mathrm{s}
\sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{z} \]</span> <span
class="math display">\[ \mathrm{succ}\sp \mathrm{n} = \lambda \sp
\mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{s} \sp
(\mathrm{n} \sp \mathrm{s} \sp \mathrm{z}) \]</span></p>
<p>The idea here is that zero takes as arguments a step function <span
class="math inline">\(\mathrm{s}\)</span> and a starting value <span
class="math inline">\(\mathrm{z}\)</span>, returning the starting value.
A positive number n, on the other hand, takes those arguments and
applies the step function to the starting value n times. Here is what
this looks like using our named terms:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- [...]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- We give ourselves some handy infix syntax for apply.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">.$</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.$) ::</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">.$</span>) <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- The unary natural numbers.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Notice here in the inductive case we reduce to normal form. </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not doing so leads to a subtly different term wherein we </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- are applying &quot;S&quot; to a term that itself is a lambda term</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- applied to two arguments but not yet Î²-reduced.</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fromNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>fromNat <span class="dt">Z</span>     <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> <span class="st">&quot;Z&quot;</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>fromNat (<span class="dt">S</span> n) <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;S&quot;</span> <span class="op">.$</span> (nf <span class="op">$</span> fromNat n <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Let us also give ourselves names for the first </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- few church numerals for convenience:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>cZero  <span class="ot">=</span> fromNat <span class="dt">Z</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>cOne   <span class="ot">=</span> fromNat (<span class="dt">S</span> <span class="dt">Z</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>cTwo   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>cThree <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>cFour  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>cFive  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))))</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>cSix   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))))</span></code></pre></div>
<p>Now recall that we wish to test how our code <em>evaluates</em> to
normal form and thus we should consider some functions to actually run.
Two such functions that come to mind are addition and multiplication.
But how are these defined for Church numerals? Remember that <span
class="math inline">\(\mathrm{n}\)</span> is meant to represent applying
a step function <span class="math inline">\(\mathrm{n}\)</span> times to
a value. If the value we apply to the step function is the result of
applying a step function argument <span
class="math inline">\(\mathrm{s}\)</span> to a starting value <span
class="math inline">\(\mathrm{m}\)</span> times, we see that this is
operationally the same as <span class="math inline">\(\mathrm{m} +
\mathrm{n}\)</span>. In lambda terms:</p>
<p><span class="math display">\[ \mathrm{add} := \lambda \mathrm{n} \sp
. \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp \mathrm{s} \sp (\mathrm{m} \sp  \mathrm{s} \sp
\mathrm{z} )
  \]</span></p>
<p>Similarly, we can define multiplication of <span
class="math inline">\(\mathrm{m}\)</span> by <span
class="math inline">\(\mathrm{n}\)</span> by applying <span
class="math inline">\(\mathrm{n}\)</span> to the step funtion <span
class="math inline">\((\mathrm{m} \sp s)\)</span> (the <span
class="math inline">\(\mathrm{m}\)</span>-fold application of <span
class="math inline">\(\mathrm{s}\)</span>) and starting value <span
class="math inline">\(\mathrm{z}\)</span>:</p>
<p><span class="math display">\[ \mathrm{mult}:= \lambda \mathrm{n} \sp
. \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp (\mathrm{m} \sp \mathrm{s}) \sp z
  \]</span></p>
<p>Let us translate this into Haskell:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">churchAdd ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>churchAdd <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> ((<span class="dt">App</span> <span class="st">&quot;n&quot;</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">churchMult ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>churchMult <span class="ot">=</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;n&quot;</span> <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>))))</span></code></pre></div>
<p>As a first check let us see that <span class="math inline">\(2 + 2
\rightsquigarrow 4\)</span> and that <span class="math inline">\(2 * 3
\rightsquigarrow 6\)</span>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span>      <span class="kw">as</span> <span class="dt">HU</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- [...]</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">unitTests ::</span> <span class="dt">TestTree</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>unitTests <span class="ot">=</span> testGroup <span class="st">&quot;Church Arithmetic Unit Tests&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  [ HU.testCase</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;2 + 2 â‡ 4&quot;</span> <span class="op">$</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      (nf <span class="op">$</span> (churchAdd <span class="op">.$</span> cTwo) <span class="op">.$</span> cTwo) <span class="op">@?=</span> cFour</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  , HU.testCase</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;2 * 3 â‡ 6&quot;</span> <span class="op">$</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      (nf <span class="op">$</span> churchMult <span class="op">.$</span> cTwo <span class="op">.$</span> cThree) <span class="op">@?=</span> cSix</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>This is fortunately the case:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Church</span> Arithmetic Unit Tests</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">2</span> + 2 â‡ 4:                         OK</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">2</span> <span class="pp">*</span> 3 â‡ 6:                         OK</span></code></pre></div>
<p>For a slightly more robust test, we can also write property tests to
check that addition and multiplication are each commutative. First we
will want to have an arbitrary instance for our definition of the unary
natural numbers:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span> n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInt</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- We convert from a randomly generated integer</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- between 0 and 50.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    arbitrary <span class="ot">=</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">50</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="op">$</span> <span class="fu">fromInt</span> i</span></code></pre></div>
<p>Now we can write our properties as follows:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">additionIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>additionIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      nf (churchAdd <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">===</span> nf (churchAdd <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">multiplicationIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>multiplicationIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>      nf (churchMult <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">===</span> nf (churchMult <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="ot">churchProperties ::</span> [<span class="dt">TestTree</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>churchProperties <span class="ot">=</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  [ QC.testProperty</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Addition of Church numerals is commutative&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>     (withMaxSuccess <span class="dv">100</span> additionIsCommutative)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  , QC.testProperty</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Multiplication of Church numerals is commutative&quot;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>     (withMaxSuccess <span class="dv">100</span> multiplicationIsCommutative)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>Running this gives us the following:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Addition</span> of Church numerals is commutative:       OK <span class="er">(</span><span class="ex">0.05s</span><span class="kw">)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Multiplication</span> of Church numerals is commutative: OK <span class="er">(</span><span class="ex">0.07s</span><span class="kw">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>It looks like our implementation might be (close to) working as
hoped! Phew.</p>
<p>We should note that one downside to our version of locally nameless
terms is that there are syntacticaly valid terms in our grammar which,
nevertheless, do not make sense as lambda terms. For example, the
following term is perfectly valid in our grammar: <span
class="math display">\[
    \lambda \sp . \sp \lambda \sp . \sp (1 \sp 3)
  \]</span></p>
<p>Here there is a bound variable <span class="math inline">\(3\)</span>
but the binding depth is only 1 (counting from <span
class="math inline">\(0\)</span>). We would like, instead, to use the
type system to enforce that each of our terms is (intrinsically) a valid
lambda term. Doing this in Haskell is quite a challenge as such an
endeavour necessarily involves types which keep track of the maximum
current binding variable, and thus dependent types. In our next post we
will see how to do this in Agda and then prove various properties of our
locally nameless terms.</p>
<p>Thank you for reading! Feel free to contact me <a
href="mailto:callan.mcgill@gmail.com">here</a> with questions, thoughts,
ideas, or all of the above.</p>]]></content>
  </entry>
  <entry>
      <title>On Characterizing Nat in Agda</title>
      <link href="https://boarders.github.ioposts/peano.html"/>
      <id>https://boarders.github.ioposts/peano.html</id>
      <updated>2020-10-06T00:00:SZ</updated>
      <category term="Agda"/>
      <category term="Natural Numbers"/>
      <summary>Explorations into characterizing natural numbers</summary>
      <content type="html"><![CDATA[<p>The 19th century brought about an unprecedented revolution in the
foundations of mathematics culminating in the Zermeloâ€“Frankel (ZF)
axioms. The ZF axioms gave a logical basis to Cantorâ€™s <em>set
theory</em> as a foundational theory, in which the main branches of
mathematics (analysis, topology, geometry and number theory) could be
encoded and thusly understood. It was through this newly-systematized
approach that the axiomatic method was born. This is of historical and
philosophical interest as it marks a decisive structuralist turn in
mathematical thought. It is at this time that mathematical objects begin
to be characterized not by any particular construction, but by the
collection of axioms (or laws) an object satisfies. <span
class="math inline">\(\def\N{\mathsf{N}}\)</span></p>
<p>Consider a paradigmatic case: characterizing the natural numbers. In
this post we will explore two different formulations of the natural
numbers, the first of which is given by Peano in the late 19th century,
and the second of which is a more categorical approach inspired by
Lawvere. This will provide us a springboard upon which to explore
<em>how</em> we can formulate and reason about mathematical structures
in Agda. Since Agda is based on dependent type theory, our formulations
will be <a
href="https://en.wikipedia.org/wiki/Constructivism_(philosophy_of_mathematics)"><em>constructive</em></a>.
This means our constructions will be <em>proof relevant</em>. In this
setting, proofs are first-class entities and as such our algebraic
structures will encode both the operations a structure has along with
proofs of the properties that it satisfies.</p>
<p>We will assume the reader has some familiarity with Agda (with
relevant materials noted throughout) and has an interest in formalizing
mathematics.</p>
<p>Let us begin with Peanoâ€™s axioms. A set <span
class="math inline">\(\N\)</span> satisfies Peanoâ€™s axioms if the
following properties hold:</p>
<ul>
<li>There exist terms <span class="math inline">\(0 \in \N\)</span> and
<span class="math inline">\(\mathrm{s} : \N \rightarrow
\N\)</span>.</li>
<li><span class="math inline">\(\N\)</span> carries an equivalence
relation <span class="math inline">\(\simeq\;\subset\N \times\N\)</span>
(to be explained below).</li>
<li><span class="math inline">\(\mathrm{s}\)</span> reflects <span
class="math inline">\(\simeq\)</span>-equivalence: <span
class="math display">\[ \forall \; \mathrm{n}, \mathrm{m} \in \N \; . \;
\mathrm{s} (\mathrm{n}) \simeq \mathrm{s} (\mathrm{m}) \Rightarrow
\mathrm{m} \simeq \mathrm{n} \]</span></li>
<li><span class="math inline">\(0\)</span> is never (equivalent to) the
successor of any number: <span class="math display">\[ \nexists \;
\mathrm{n} \in \mathbb{N} \; . \; \mathrm{s}(n) \simeq 0 \]</span></li>
<li><span class="math inline">\(\N\)</span> satisfies induction: if
<span class="math inline">\(\phi : \N \rightarrow \mathbb{B}\)</span> is
a predicate and the following conditions hold:
<ul>
<li><span class="math inline">\(\phi(0)\)</span> is true.</li>
<li><span class="math inline">\(\forall \; \mathrm{n} \in \mathbb{N} \;
. \; \phi(n) \Rightarrow \phi(\mathrm{s}(\mathrm{n}))\)</span></li>
</ul>
then <span class="math inline">\(\phi\)</span> is true for all <span
class="math inline">\(\mathrm{n} \in \N\)</span>.</li>
</ul>
<p>How can we prove that this uniquely determines the natural numbers?
Our strategy would go roughly as follows:</p>
<ul>
<li>Give a particular construction of <span
class="math inline">\(\mathbb{N}\)</span> showing it satisfies the
axioms.</li>
<li>For any set <span class="math inline">\(\N\)</span> satisfying the
axioms, construct maps: <span class="math display">\[\begin{aligned}
  \mathrm{from} &amp;: \mathbb{N} \rightarrow \mathsf{N} \\
  \mathrm{to}   &amp;: \mathsf{N} \rightarrow \mathbb{N} \\
\end{aligned}\]</span></li>
<li>Use induction with the following predicates: <span
class="math display">\[\begin{aligned}
  \phi_{\mathbb{N}}(n) &amp;= n \simeq_\mathbb{N} \mathrm{to} \circ
\mathrm{from}(n) \\
  \phi_{\mathsf{N}}(n) &amp;= n \simeq_\mathsf{N} \mathrm{to} \circ
\mathrm{from} (n)
\end{aligned}\]</span> to show the these maps form an equivalence.</li>
</ul>
<p>Letâ€™s try to formalise this constructively in Agda. We start with a
few imports we will need later:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Peano <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>PropositionalEquality</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>â‰¡<span class="ot">_;</span> refl<span class="ot">;</span> <span class="ot">_</span>â‰¢<span class="ot">_;</span> cong<span class="ot">;</span> trans<span class="ot">;</span> sym<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Function</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>âˆ˜<span class="ot">_)</span></span></code></pre></div>
<p>Typically, we define the (unary) natural numbers as follows:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> â„• <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  Zero <span class="ot">:</span> â„•</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  Succ <span class="ot">:</span> â„• <span class="ot">-&gt;</span> â„•</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">{-# BUILTIN NATURAL â„• #-}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- This allows us to use numeric literals.</span></span></code></pre></div>
<p>Our first port of call is to formulate equivalence relations. In Agda
we usually encode algebraic structures as <a
href="https://agda.readthedocs.io/en/v2.6.1.1/language/record-types.html">records</a>.
As mentioned in the introduction, since proofs are first-class, we carry
around not just the structure of the binary relation but also the
properties it satisfies:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> EqRel <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Setâ‚ <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>â‰ƒ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    reflexivity  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span>     <span class="ot">â†’</span> a â‰ƒ a</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    symmetry     <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span>   <span class="ot">â†’</span> a â‰ƒ b <span class="ot">â†’</span> b â‰ƒ a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    transitivity <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b c <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">â†’</span> a â‰ƒ b <span class="ot">â†’</span> b â‰ƒ c <span class="ot">â†’</span> a â‰ƒ c</span></code></pre></div>
<p>We note that this definition is slightly different from what is
typical in mathematics. Rather than a <em>subset</em> of the diagonal,
we make use of a two-argument dependent type <span
class="math inline">\(\_ \simeq \_\)</span>. Given <span
class="math inline">\(\mathrm{a}, \mathrm{b} : \mathrm{A}\)</span>, the
type <span class="math inline">\(\mathrm{a}\;\simeq\;\mathrm{b}\)</span>
gives the collection of <em>evidence</em> that <span
class="math inline">\(\mathrm{a}\)</span> and <span
class="math inline">\(\mathrm{b}\)</span> are equal. The axioms this
satisfies are reflexivity (that any element is equal to itself) symmetry
(that we can freely reverse equalities) and transitivity (that we can
compose equalities).</p>
<p>Letâ€™s show that Agdaâ€™s built-in equality type, <span
class="math inline">\(\equiv\)</span>, is an equivalence relation on
<span class="math inline">\(\mathbb{N}\)</span>. As a brief reminder,
here is how the equality type is defined, if we ignore <a
href="https://agda.readthedocs.io/en/v2.6.1.1/language/universe-levels.html">level
polymorphism</a>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="ot">_</span>â‰¡<span class="ot">_</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  refl <span class="ot">:</span> x â‰¡ x</span></code></pre></div>
<p>That is to say, we can give a term <span
class="math inline">\(\mathrm{refl}\)</span> of type <span
class="math inline">\(\mathrm{a} \equiv \mathrm{b}\)</span> so long as
Agda can directly compute that <span
class="math inline">\(\mathrm{a}\)</span> and <span
class="math inline">\(\mathrm{b}\)</span> are equal within the
particular context. For example, if we define addition:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">-&gt;</span> â„• <span class="ot">-&gt;</span> â„•</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> Zero     m <span class="ot">=</span> m</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">(</span>Succ n<span class="ot">)</span> m <span class="ot">=</span> Succ <span class="ot">(</span>n + m<span class="ot">)</span></span></code></pre></div>
<p>then we can give the following (unnamed) definition:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> <span class="ot">:</span> <span class="dv">2</span> + <span class="dv">2</span> â‰¡ <span class="dv">4</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>as Agda can compute that both sides are equal.</p>
<p>Coming back to <span class="math inline">\(\mathbb{N}\)</span>, letâ€™s
show how <span class="math inline">\(\equiv\)</span> satisfies the
properties of an equivalence relation:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>â„•-refl <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> n â‰¡ n</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>â„•-refl <span class="ot">=</span> refl</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>â„•-symm <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n m <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> n â‰¡ m <span class="ot">â†’</span> m â‰¡ n</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>â„•-symm nâ‰¡m <span class="kw">rewrite</span> nâ‰¡m <span class="ot">=</span> refl</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>â„•-trans <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m n r <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> m â‰¡ n <span class="ot">â†’</span> n â‰¡ r <span class="ot">â†’</span> m â‰¡ r</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>â„•-trans  mâ‰¡n nâ‰¡r <span class="kw">rewrite</span> mâ‰¡n <span class="ot">|</span> nâ‰¡r <span class="ot">=</span> refl</span></code></pre></div>
<p>Here we make use of Agdaâ€™s <a
href="https://agda.readthedocs.io/en/v2.6.1/language/with-abstraction.html#with-rewrite">rewrite
construction</a>. By providing an equality proof of the form <span
class="math inline">\(\mathrm{a} \equiv \mathrm{b}\)</span>, the rewrite
construction will replace subexpressions in the goal of the form <span
class="math inline">\(\mathrm{a}\)</span> with <span
class="math inline">\(\mathrm{b}\)</span>. For example, in <span
class="math inline">\(\mathbb{N}\mathrm{-symm}\)</span>, we use the
equality term we are given, <span class="math inline">\(\mathrm{n}
\equiv \mathrm{m}\)</span>, as an argument to rewrite so that each
appearance of <span class="math inline">\(\mathrm{n}\)</span> is
replaced with <span class="math inline">\(\mathrm{m}\)</span>. At this
point we may fill the hole with <span
class="math inline">\(\mathrm{refl} : \mathrm{m} \equiv
\mathrm{m}\)</span>.</p>
<p>It is worth noting that we havenâ€™t used anything special about <span
class="math inline">\(\mathbb{N}\)</span> and these same definitions
would work to prove that <em>any</em> set forms an equivalence relation
under <span class="math inline">\(\equiv\)</span>.</p>
<p>Now we can write an instance of EqRel for <span
class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> EqRel <span class="ot">{{...}}</span> <span class="kw">public</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  â‰¡-Nat <span class="ot">:</span> EqRel â„•</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  â‰¡-Nat <span class="ot">=</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">record</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{</span> <span class="ot">_</span>â‰ƒ<span class="ot">_</span>          <span class="ot">=</span> <span class="ot">_</span>â‰¡<span class="ot">_</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> reflexivity  <span class="ot">=</span> â„•-refl</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> symmetry     <span class="ot">=</span> â„•-symm</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> transitivity <span class="ot">=</span> â„•-trans</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">}</span></span></code></pre></div>
<p>Here we use Agdaâ€™s <a
href="https://agda.readthedocs.io/en/v2.6.1.1/language/instance-arguments.html">instance
arguments</a> mechanism, the analog to Haskellâ€™s typeclass instances. We
start by bringing the fields of EqRel into scope for those instances
which can be resolved. This is essentially equivalent to us defining
top-level functions of the form:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>â‰ƒ<span class="ot">_</span>         <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>reflexivity <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>a â‰ƒ a<span class="ot">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>Implicit arguments <span class="math inline">\(\{\{\_ :
\mathrm{EqRel}\; \mathrm{A}\}\}\)</span> are resolved by searching for
instances we have available in scope. In particular, we define an
instance of EqRel for <span class="math inline">\(\mathbb{N}\)</span>
which means that we may use these methods on <span
class="math inline">\(\mathbb{N}\)</span> and Agda will infer the
instance we have provided.</p>
<p>Now we are in a position to formalise the Peano axioms. In much the
same way as we have done with equivalence relations, we again use
records to encode algebraic structure:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Peano <span class="ot">(</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">{{</span>rel <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">:</span> Setâ‚ <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    zero        <span class="ot">:</span> N</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    succ        <span class="ot">:</span> N <span class="ot">â†’</span> N</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    s-injective <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>succ a<span class="ot">)</span> â‰ƒ <span class="ot">(</span>succ b<span class="ot">)</span> <span class="ot">â†’</span> a â‰ƒ b</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    zeroâ‰ succ   <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span> <span class="ot">â†’</span> zero â‰ƒ <span class="ot">(</span>succ a<span class="ot">)</span> <span class="ot">â†’</span> âŠ¥</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    induction   <span class="ot">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>       <span class="ot">âˆ€</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>z <span class="ot">:</span> P zero<span class="ot">)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">â†’</span> P b <span class="ot">â†’</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> P a</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    induction-zero <span class="ot">:</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>       <span class="ot">âˆ€</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>z <span class="ot">:</span> P zero<span class="ot">)</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">â†’</span> P b <span class="ot">â†’</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>induction P zero z s â‰¡ z<span class="ot">)</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    induction-succ <span class="ot">:</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>       <span class="ot">âˆ€</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>z <span class="ot">:</span> <span class="ot">(</span>P zero<span class="ot">))</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">â†’</span> P b <span class="ot">â†’</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>       <span class="ot">â†’</span> <span class="ot">(</span>induction P <span class="ot">(</span>succ a<span class="ot">)</span> z s â‰¡ s <span class="ot">(</span>induction P a z s<span class="ot">))</span></span></code></pre></div>
<p>Several things are worth noting about this defintion:</p>
<ul>
<li>We again make use of instance arguments so that the input type <span
class="math inline">\(\N\)</span> has the structure of an equivalence
relation. This is somewhat similar to a typeclass extension definition
in Haskell:</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a</span></code></pre></div>
<ul>
<li>We upgrade induction from a unary predicate <span
class="math inline">\(\phi : \N \rightarrow \mathbb{B}\)</span> to a
dependent type <span class="math inline">\(\mathrm{P} : \N \rightarrow
\mathrm{Set}\)</span>.</li>
<li>As we will see later, we would like this upgraded principle to be
able to <em>compute</em>. As such we add two laws that dictate how
computation should unfold.</li>
</ul>
<p>Letâ€™s now prove that <span class="math inline">\(\mathbb{N}\)</span>
satisfies induction and injectivity of <span
class="math inline">\(\mathrm{Succ}\)</span>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>â„•-induction <span class="ot">:</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">(</span>P <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> â„•<span class="ot">)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>P Zero<span class="ot">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>b <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>P b<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>P <span class="ot">(</span>Succ b<span class="ot">)))</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>P a<span class="ot">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>â„•-induction P Zero p[zero] p[succ] <span class="ot">=</span> p[zero]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>â„•-induction P <span class="ot">(</span>Succ n<span class="ot">)</span> p[zero] p[succ]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> p[succ] <span class="ot">(</span>â„•-induction P n p[zero] p[succ]<span class="ot">)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>Succ-inj <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n m <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>Succ n<span class="ot">)</span> â‰¡ <span class="ot">(</span>Succ m<span class="ot">)</span> <span class="ot">â†’</span> n â‰¡ m</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>Succ-inj refl <span class="ot">=</span> refl</span></code></pre></div>
<p>This is much as we might expect, induction is identical to the
recursion principle for <span class="math inline">\(\mathbb{N}\)</span>
and <span class="math inline">\(\mathrm{Succ}\)</span>-<span
class="math inline">\(\mathrm{inj}\)</span> follows definitionally after
we case match on equality. We can now make <span
class="math inline">\(\mathbb{N}\)</span> an instance of <span
class="math inline">\(\mathrm{Peano}\)</span>:</p>
<pre><code>instance
  â„•-Peano : Peano â„•
  â„•-Peano =
    record
      { zero           = Zero
      ; succ           = Succ
      ; s-injective    = Succ-inj
      ; zeroâ‰ succ      = Î» n ()
      ; induction      = â„•-induction
      ; induction-zero = Î» P z s   â†’ refl
      ; induction-succ = Î» P a z s â†’ refl
      }</code></pre>
<p>In the last two cases, the <span
class="math inline">\(\mathrm{induction}\)</span> laws hold
definitionally from how we have defined <span
class="math inline">\(\mathbb{N}\)</span>-<span
class="math inline">\(\mathrm{induction}\)</span>.</p>
<p>Now, suppose <span class="math inline">\(\mathsf{N}\)</span> is a set
satisfying the Peano axioms, we want to then define functions to and
from <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>from-â„• <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> N</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>from-â„• <span class="ot">{</span>N<span class="ot">}</span> n <span class="ot">=</span> induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">-&gt;</span> N<span class="ot">)</span> n zero succ</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>to-â„• <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{_</span> <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">â†’</span> N <span class="ot">â†’</span> â„•</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>to-â„• n <span class="ot">=</span> induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> n zero succ</span></code></pre></div>
<p>Pleasantly both definitions are essentially identical, using instance
resolution to determine the relevant induction principle and values to
use. Here we see the power of constructive induction. We donâ€™t use
induction to prove a <em>property</em> per se, but to compute. Since the
dependent types in question are constant, induction simply <em>is</em>
recursion!</p>
<p>Now we can show these maps form equivalences. To get a flavour let us
step through the development for the first equality:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>toâˆ˜from <span class="ot">:</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> to-â„• <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-â„• n<span class="ot">)</span> â‰¡ n</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>toâˆ˜from n <span class="ot">=</span> <span class="ot">{!!}</span></span></code></pre></div>
<p>Asking Agda for the goal gives us:</p>
<pre class="terminal"><code>Goal: Peano.induction peano (Î» _ â†’ â„•)
      (â„•-induction (Î» _ â†’ N) n (Peano.zero peano) (Peano.succ peano)) 0
      Succ
      â‰¡ n
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
n     : â„•
peano : Peano N  (not in scope, instance)
_     : EqRel N    (instance)
N     : Set      (not in scope)
</code></pre>
<p>We can see that in order for <span
class="math inline">\(\mathbb{N}\)</span>-<span
class="math inline">\(\mathrm{induction}\)</span> to make progress we
need to split on <span class="math inline">\(\mathrm{n}\)</span>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>toâˆ˜from <span class="ot">:</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> to-â„• <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-â„• n<span class="ot">)</span> â‰¡ n</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>toâˆ˜from Zero     <span class="ot">=</span> <span class="ot">{!!}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>toâˆ˜from <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">{!!}</span></span></code></pre></div>
<p>The new goal for <span class="math inline">\(\mathrm{Zero}\)</span>
is:</p>
<pre class="terminal"><code>Goal: Peano.induction peano (Î» _ â†’ â„•) (Peano.zero peano) 0 Succ â‰¡ 0</code></pre>
<p>But this is precisely our <span
class="math inline">\(\mathrm{induction}\)</span>-<span
class="math inline">\(\mathrm{zero}\)</span> principle! Similarly we can
now use the <span
class="math inline">\(\mathrm{induction}\)</span>-<span
class="math inline">\(\mathrm{succ}\)</span> principle in the second
case and then recurse giving us:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>toâˆ˜from <span class="ot">:</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> to-â„• <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-â„• n<span class="ot">)</span> â‰¡ n</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>toâˆ˜from Zero <span class="ot">=</span>  <span class="ot">(</span>induction-zero <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>toâˆ˜from <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_}}</span> <span class="ot">{{</span>peano<span class="ot">}}</span> <span class="ot">(</span>Succ n<span class="ot">)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>induction-succ</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(</span>â„•-induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> N<span class="ot">)</span> n <span class="ot">(</span>Peano<span class="ot">.</span>zero peano<span class="ot">)</span> <span class="ot">(</span>Peano<span class="ot">.</span>succ peano<span class="ot">))</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>      Zero</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>      Succ<span class="ot">)</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">|</span> toâˆ˜from <span class="ot">{</span>N<span class="ot">}</span> n</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> refl</span></code></pre></div>
<p>The slightly gnarly explicit arguments in the second case are to help
along the rewrite construction as it didnâ€™t seem to cooperate with a
less verbose alternative.</p>
<p>The other proof is similarly a case of following our nose (or rather
following the typechecker). We first remind ourselves of some equality
principles we have imported above (again simplifying away level
polymorphism):</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Funtions preserve equality:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>cong</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">{</span>x y <span class="ot">:</span> A<span class="ot">}</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> x â‰¡ y <span class="ot">â†’</span> f x â‰¡ f y</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- The transitivity principle for â‰¡</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>trans <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b c <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">â†’</span> a â‰¡ b <span class="ot">â†’</span> b â‰¡ c <span class="ot">â†’</span> a â‰¡ c</span></code></pre></div>
<p>We also will need the fact that we can lift any propositional
equality into an equivalence relation:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>liftEq <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>  <span class="ot">{{</span>r <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">â†’</span> a â‰¡ b <span class="ot">â†’</span> <span class="ot">(</span>a â‰ƒ b<span class="ot">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>liftEq refl <span class="ot">=</span> reflexivity</span></code></pre></div>
<p>With these can now give the proof:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>fromâˆ˜to <span class="ot">:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{{</span> rel <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">â†’</span> <span class="ot">(</span>n <span class="ot">:</span> N<span class="ot">)</span> <span class="ot">â†’</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  from-â„• <span class="ot">(</span>to-â„• n<span class="ot">)</span> â‰ƒ n</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>fromâˆ˜to <span class="ot">{</span>N<span class="ot">}</span> n <span class="ot">=</span> liftEq <span class="ot">(</span>prop-eq <span class="ot">{</span>N<span class="ot">})</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">-- We make use of liftEq as we prove the</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">-- stronger claim that from-â„• (to-â„• n) â‰¡ n</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- In the zero case we apply induction-zero underneath from-â„•</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and then use the definition of from-â„•.</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  zero-lem</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> from-â„• <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>induction <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> zero Zero Succ<span class="ot">)</span> â‰¡ zero</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  zero-lem <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">:</span> from-â„• <span class="ot">(</span>induction <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> zero Zero Succ<span class="ot">)</span> â‰¡ from-â„• Zero</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">=</span> cong from-â„• <span class="ot">(</span>induction-zero <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">:</span> from-â„• Zero â‰¡ zero</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">=</span> refl</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>      trans pf1 pf2</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- In the successor case we similarly apply induction-succ</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- underneath from-â„• and then recurse on the previous proof.</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  succ-lem</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">(</span>prev <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> from-â„• <span class="ot">(</span>induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> prev Zero Succ<span class="ot">)</span> â‰¡ prev</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> from-â„• <span class="ot">(</span>induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> <span class="ot">(</span>succ prev<span class="ot">)</span> Zero Succ<span class="ot">)</span> â‰¡ succ prev</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  succ-lem prev pf <span class="ot">=</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">:</span> from-â„• <span class="ot">(</span>induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> <span class="ot">(</span>succ prev<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>          â‰¡ from-â„• <span class="ot">(</span>Succ <span class="ot">(</span>induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> prev Zero Succ<span class="ot">))</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">=</span> cong from-â„• <span class="ot">(</span>induction-succ <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> prev Zero Succ<span class="ot">)</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">:</span> from-â„• <span class="ot">(</span>Succ <span class="ot">(</span>induction <span class="ot">(Î»</span> <span class="ot">_</span> <span class="ot">â†’</span> â„•<span class="ot">)</span> prev Zero Succ<span class="ot">))</span> â‰¡ <span class="ot">(</span>succ prev<span class="ot">)</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">=</span> cong succ pf</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>      trans pf1 pf2</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>  prop-eq</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> from-â„• <span class="ot">(</span>to-â„• n<span class="ot">)</span> â‰¡ n</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>  prop-eq <span class="ot">=</span></span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>      induction</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- we use induction on the principle</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- we are trying to show with the above</span></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- lemmas.</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(Î»</span> n <span class="ot">â†’</span> from-â„• <span class="ot">(</span>to-â„•  n<span class="ot">)</span> â‰¡ n<span class="ot">)</span></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>        n</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>        zero-lem</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(Î»</span> <span class="ot">{</span>prev<span class="ot">}</span> <span class="ot">â†’</span> succ-lem prev<span class="ot">)</span></span></code></pre></div>
<p>This shows that any two types which satisfy the Peano axioms are
equivalent in the sense that there are maps between them which form an
isomorphism up to equivalence.</p>
<p>This is quite interesting as it stands, but we might wonder if there
is a more direct characterization of the natural numbers. After all, our
original definition as a recursive algebraic data type seems to give a
perfectly good specification of what the natural numbers <em>are</em>.
Let us turn to a characterization of <span
class="math inline">\(\mathbb{N}\)</span> given by Lawvere.</p>
<p>We define the category of discrete dynamical systems, whose:</p>
<ul>
<li>Objects are sets <span class="math inline">\(X\)</span> equipped
with a starting point <span class="math inline">\(x_0 \in X\)</span> and
a self-map <span class="math inline">\(f : X \rightarrow
X\)</span>.</li>
<li>Morphisms are functions <span class="math inline">\(\phi : X
\rightarrow Y\)</span> which take basepoint to basepoint and which
commute with the self-map: <span class="math display">\[
\begin{array}{lll}
X          &amp; \xrightarrow{\phi} &amp; Y      \\
\downarrow &amp;             &amp; \downarrow    \\
X          &amp; \xrightarrow{\phi} &amp; Y      \\
\end{array}
\]</span></li>
</ul>
<p>Lawvere then observed that the natural numbers are the <a
href="https://ncatlab.org/nlab/show/initial+object">initial object</a>
in the category of discrete dynamical systems. In other words, every
other dynamical system receives a <em>unique</em> map from the discrete
dynamical system <span class="math inline">\(\left( \mathbb{N}\; , \; 0
: \mathbb{N}\; ,\; \mathrm{s}\; : \; \mathbb{N} \rightarrow
\mathbb{N}\right)\)</span>.</p>
<p>Let us phrase this idea in terms of language more familiar to
functional programmers. First define a â€œpattern functorâ€ for <span
class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> NatP <span class="ot">(</span>r <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  ZeroP <span class="ot">:</span> NatP r</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  SuccP <span class="ot">:</span> r <span class="ot">â†’</span> NatP r</span></code></pre></div>
<p>This has the same shape as <span
class="math inline">\(\mathbb{N}\)</span> but we leave the recursion
open (this same pattern of open recursion is the animating idea behind
<a
href="https://hackage.haskell.org/package/recursion-schemes">recursion
schemes</a>). We can show that this is a functor (we donâ€™t worry about
the functor laws):</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Functor <span class="ot">(</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Setâ‚ <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> Func</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    Arr <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>f <span class="ot">:</span> A <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">â†’</span> F A <span class="ot">â†’</span> F B</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Functor <span class="ot">{{...}}</span> <span class="kw">public</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  NatP-Functor <span class="ot">:</span> Functor NatP</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  NatP-Functor <span class="ot">=</span> Func map</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    map <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">â†’</span> NatP A <span class="ot">â†’</span> NatP B</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    map f ZeroP     <span class="ot">=</span> ZeroP</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    map f <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> SuccP <span class="ot">(</span>f x<span class="ot">)</span></span></code></pre></div>
<p>Functional programmers might recognise that the discrete dynamical
systems discussed above are in fact <a
href="https://en.wikipedia.org/wiki/F-algebra"><span
class="math inline">\(\mathrm{F}\)</span>-algebras</a> for this pattern
functor, which we define as follows:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Alg <span class="ot">(</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    Î¼ <span class="ot">:</span> F A <span class="ot">â†’</span> A</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Alg <span class="ot">{{...}}</span> <span class="kw">public</span></span></code></pre></div>
<p>In particular if we define discrete dynamical systems:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Dyn <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> D</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    basepoint <span class="ot">:</span> A</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    self-map  <span class="ot">:</span> A <span class="ot">â†’</span> A</span></code></pre></div>
<p>then we can show then any dynamical system gives rise to an
algebra:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>from-Dyn <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">â†’</span> Dyn A <span class="ot">â†’</span> Alg NatP A</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>from-Dyn <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">(</span>D basepoint self-map<span class="ot">)</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> Î¼ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">:</span> NatP A <span class="ot">â†’</span> A</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  alg ZeroP     <span class="ot">=</span> basepoint</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">(</span>SuccP a<span class="ot">)</span> <span class="ot">=</span> self-map a</span></code></pre></div>
<p>and we leave, as an exercise, to show that there is an isomorphism
between <span class="math inline">\(\mathrm{NatP}\)</span> algebra
structures on <span class="math inline">\(\mathrm{A}\)</span> and
discrete dynamical system structures (an observation we can upgrade to
an isomorphism between the respective categories).</p>
<p>Letâ€™s give the algebra structure for <span
class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  â„•-Alg <span class="ot">:</span> Alg NatP â„•</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  â„•-Alg <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> Î¼ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">:</span> NatP â„• <span class="ot">â†’</span> â„•</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    alg ZeroP     <span class="ot">=</span> Zero</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> Succ x</span></code></pre></div>
<p>Just as in Lawvereâ€™s characterization, we now wish to show that this
algebra is initial. For that, we first have to define maps between
algebras. Suppose <span class="math inline">\(\mathrm{A}\)</span> and
<span class="math inline">\(\mathrm{B}\)</span> are <span
class="math inline">\(\mathrm{F}\)</span>-algebras. We then say a map
<span class="math inline">\(m : \mathrm{A} \rightarrow
\mathrm{B}\)</span> is an <span
class="math inline">\(\mathrm{F}\)</span>-algebra homomorphism when the
following diagram commutes (where the downward arrows are the algebra
maps):</p>
<p><span class="math display">\[
\begin{array}{lll}
F A          &amp; \xrightarrow{F m} &amp; F B  \\
\downarrow &amp;             &amp; \downarrow   \\
A          &amp; \xrightarrow{m} &amp; B        \\
\end{array}
\]</span></p>
<p>In other words, the algebra map commutes with the map in question, or
in equations: <span class="math display">\[
f \circ \mu_{A} \equiv \mu_{B} \circ (F f)
\]</span></p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Alg-Homo <span class="ot">(</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">{</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">â†’</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span>f <span class="ot">:</span> Functor F<span class="ot">}}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(</span>FA <span class="ot">:</span> Alg F A<span class="ot">)</span> <span class="ot">(</span>FB <span class="ot">:</span> Alg F B<span class="ot">)</span> <span class="ot">:</span> Setâ‚ <span class="kw">where</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> AlgHom</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    â†’-fun  <span class="ot">:</span> A <span class="ot">â†’</span> B</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    Î¼-comm</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>fa <span class="ot">:</span> F A<span class="ot">)</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">â†’</span> â†’-fun <span class="ot">(</span>Alg<span class="ot">.</span>Î¼ FA fa<span class="ot">)</span> â‰¡ <span class="ot">(</span>Alg<span class="ot">.</span>Î¼ FB<span class="ot">)</span> <span class="ot">(</span>Arr â†’-fun fa<span class="ot">)</span></span></code></pre></div>
<p>Now we can try to prove that the algebra structure on <span
class="math inline">\(\mathbb{N}\)</span> is initial. We first show
there is an induced map to every other <span
class="math inline">\(\mathrm{F}\)</span>-<span
class="math inline">\(\mathrm{algebra}\)</span>:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>â„•-weakly-initial</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg NatP A<span class="ot">}}</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> Alg-Homo â„• A â„•-Alg FA</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>â„•-weakly-initial <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> AlgH init-â„• law</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  init-â„• <span class="ot">:</span> â„• <span class="ot">â†’</span> A</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  init-â„• Zero     <span class="ot">=</span> Î¼ ZeroP</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  init-â„• <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span> Î¼ <span class="ot">(</span>SuccP <span class="ot">(</span>init-â„• n<span class="ot">))</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">:</span> <span class="ot">(</span>nP <span class="ot">:</span> NatP â„•<span class="ot">)</span> <span class="ot">â†’</span> init-â„• <span class="ot">(</span>Î¼ nP<span class="ot">)</span> â‰¡ Î¼ <span class="ot">(</span>Arr init-â„• nP<span class="ot">)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  law ZeroP     <span class="ot">=</span> refl</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>We define the map via the structure of the algebra. <span
class="math inline">\(\mathrm{Zero}\)</span> maps to the basepoint of
<span class="math inline">\(\mathrm{A}\)</span> and for the successor we
apply the self-map and then recurse. For the <span
class="math inline">\(\mu\)</span>-<span
class="math inline">\(\mathrm{law}\)</span> we first case split as this
is how <span class="math inline">\(\mathrm{init}\)</span>-<span
class="math inline">\(\mathbb{N}\)</span> is defined. At this point we
can see that the laws hold definitionally from how we have defined the
map.</p>
<p>We can then show uniqueness:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>â„•-init-uniq <span class="ot">:</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">âˆ€</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg NatP A<span class="ot">}}</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>alg-hom <span class="ot">:</span> Alg-Homo â„• A â„•-Alg FA<span class="ot">)</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">(</span>Alg-Homo<span class="ot">.</span>â†’-fun alg-hom n<span class="ot">)</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  â‰¡ <span class="ot">(</span>Alg-Homo<span class="ot">.</span>â†’-fun <span class="ot">(</span>â„•-weakly-initial <span class="ot">{{</span>FA<span class="ot">}})</span> n<span class="ot">)</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>â„•-init-uniq alg-hom Zero <span class="ot">=</span> Î¼-comm ZeroP</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">open</span> Alg-Homo alg-hom <span class="kw">public</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>â„•-init-uniq <span class="ot">{{</span>FA<span class="ot">}}</span> alg-hom <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">:</span>  â†’-fun <span class="ot">(</span>Succ n<span class="ot">)</span> â‰¡ Î¼ <span class="ot">(</span>SuccP <span class="ot">(</span>â†’-fun n<span class="ot">))</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">=</span> Î¼-comm <span class="ot">(</span>SuccP n<span class="ot">)</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">:</span>  Î¼ <span class="ot">(</span>SuccP <span class="ot">(</span>â†’-fun n<span class="ot">))</span> â‰¡ Î¼ <span class="ot">(</span>SuccP <span class="ot">(</span>Alg-Homo<span class="ot">.</span>â†’-fun â„•-weakly-initial n<span class="ot">))</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">=</span> cong <span class="ot">(</span>Î¼ âˆ˜ SuccP<span class="ot">)</span> <span class="ot">(</span>â„•-init-uniq alg-hom n<span class="ot">)</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    trans pf1 pf2</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">open</span> Alg-Homo alg-hom <span class="kw">public</span></span></code></pre></div>
<p>We donâ€™t infer algebra homomorphisms and so we need to pass them as
arguments and open the various records to bring their fields into scope.
In the first case we have the following goal:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>â†’-fun <span class="dv">0</span> â‰¡ Î¼ ZeroP</span></code></pre></div>
<p>We note that this is definitionally equivalent to showing:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>â†’-fun <span class="ot">(</span>Î¼ ZeroP<span class="ot">)</span> â‰¡ Î¼ <span class="ot">(</span>Arr â†’-fun ZeroP<span class="ot">)</span></span></code></pre></div>
<p>and this is the <span class="math inline">\(\mu\)</span>-<span
class="math inline">\(\mathrm{comm}\)</span> law!</p>
<p>In the successor case we have to prove:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>â†’-fun <span class="ot">(</span>Succ n<span class="ot">)</span> â‰¡ Î¼ <span class="ot">(</span>SuccP <span class="ot">(</span>Alg-Homo<span class="ot">.</span>â†’-fun â„•-weakly-initial n<span class="ot">))</span></span></code></pre></div>
<p>We use a similar observation as above to first rewrite the
left-hand-side using the <span class="math inline">\(\mu\)</span>-<span
class="math inline">\(\mathrm{comm}\)</span> law. At that point (as
before) we can rewrite the inner part by recursion.</p>
<p>One nice thing about this characterization (beyond being much simpler
to reason about!) is that the same idea of initial algebra semantics
works just as well for any algebraic data type. For example we can do
exactly the same for lists as we have for <span
class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> ListP <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>r <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  NilP  <span class="ot">:</span> ListP A r</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  ConsP <span class="ot">:</span> A <span class="ot">â†’</span> r <span class="ot">â†’</span> ListP A r</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  Nil  <span class="ot">:</span> List A</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  Cons <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> List A</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  ListP-Functor <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">â†’</span>  Functor <span class="ot">(</span>ListP A<span class="ot">)</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  ListP-Functor <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> Func map-L</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    map-L <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">{</span>C<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>B <span class="ot">â†’</span> C<span class="ot">)</span> <span class="ot">â†’</span> ListP A B <span class="ot">â†’</span> ListP A C</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    map-L f NilP <span class="ot">=</span> NilP</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    map-L f <span class="ot">(</span>ConsP a b<span class="ot">)</span> <span class="ot">=</span> ConsP a <span class="ot">(</span>f b<span class="ot">)</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> HasFold <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Setâ‚ <span class="kw">where</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> F</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    initial  <span class="ot">:</span> B</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    operator <span class="ot">:</span> A <span class="ot">â†’</span> B <span class="ot">â†’</span> B</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>fromHasFold <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">â†’</span>  HasFold A B <span class="ot">â†’</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>fromHasFold <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">(</span>F initial operator<span class="ot">)</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> Î¼ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">:</span> ListP A B <span class="ot">â†’</span> B</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>  alg NilP <span class="ot">=</span> initial</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">(</span>ConsP a b<span class="ot">)</span> <span class="ot">=</span> operator a b</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>toHasFold <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">â†’</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B <span class="ot">â†’</span> HasFold A B</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>toHasFold <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="kw">record</span> <span class="ot">{</span> Î¼ <span class="ot">=</span> Î¼ <span class="ot">}</span> <span class="ot">=</span> F init op</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>  init <span class="ot">:</span> B</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>  init <span class="ot">=</span> Î¼ NilP</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>  op <span class="ot">:</span> A <span class="ot">â†’</span> B <span class="ot">â†’</span> B</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>  op a b <span class="ot">=</span> Î¼ <span class="ot">(</span>ConsP a b<span class="ot">)</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>  List-Alg <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">â†’</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> <span class="ot">(</span>List A<span class="ot">)</span></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>  List-Alg <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> Î¼ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">:</span> ListP A <span class="ot">(</span>List A<span class="ot">)</span> <span class="ot">â†’</span> List A</span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    alg NilP <span class="ot">=</span> Nil</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">(</span>ConsP a as<span class="ot">)</span> <span class="ot">=</span> Cons a as</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>foldr <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> B <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">â†’</span> B <span class="ot">â†’</span> List A <span class="ot">â†’</span> B</span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>foldr op init Nil         <span class="ot">=</span> init</span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>foldr op init <span class="ot">(</span>Cons a as<span class="ot">)</span> <span class="ot">=</span> op a <span class="ot">(</span>foldr op init as<span class="ot">)</span></span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>foldr-Alg <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B<span class="ot">}}</span></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> List A <span class="ot">â†’</span> B</span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>foldr-Alg <span class="ot">=</span> foldr <span class="ot">(Î»</span> a b <span class="ot">â†’</span> Î¼ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>Î¼ NilP<span class="ot">)</span></span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>List-weakly-initial</span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B<span class="ot">}}</span></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>  <span class="ot">â†’</span> Alg-Homo <span class="ot">(</span>List A<span class="ot">)</span> B <span class="ot">(</span>List-Alg <span class="ot">{</span>A<span class="ot">})</span> FA</span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>List-weakly-initial <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">=</span> AlgHom foldr-Alg law</span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">:</span> <span class="ot">(</span>fa <span class="ot">:</span> ListP A <span class="ot">(</span>List A<span class="ot">))</span> <span class="ot">â†’</span></span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a>    foldr <span class="ot">(Î»</span> a b <span class="ot">â†’</span> Î¼ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>Î¼ NilP<span class="ot">)</span> <span class="ot">(</span>Î¼ fa<span class="ot">)</span></span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a>      â‰¡</span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a>    Î¼ <span class="ot">(</span>Arr <span class="ot">(</span>foldr <span class="ot">(Î»</span> a b <span class="ot">â†’</span> Î¼ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>Î¼ NilP<span class="ot">))</span> fa<span class="ot">)</span></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a>  law NilP         <span class="ot">=</span> refl</span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">(</span>ConsP a as<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>and we see that out of initiality naturally comes <span
class="math inline">\(\mathrm{foldr}\)</span>! <span
class="math inline">\(\mathrm{F}\)</span>-algebra semantics give rise to
<em>recursion principles</em>! The essence of <span
class="math inline">\(\mathbb{N}\)</span>, from this point of view, lies
in its recursive structure. After all, in a dependently-typed setting
recursion and induction are really two sides of the same coin.</p>
<p>Thank you for reading! The full code for these examples is available
<a
href="https://github.com/Boarders/agda-peano/blob/master/Peano.agda">here</a>.
Hopefully this has given some ideas for how we can explore mathematical
ideas in Agda leveraging the typechecker to guide our proofs. Feel free
to contact me <a href="mailto:callan.mcgill@gmail.com">here</a> with
questions, thoughts, ideas, or all of the above.</p>
<p><i>With warmest thanks to Sam Derbyshire, Reed Mullanix, Alixandra
Prybyla and Shon Feder for their valuable feedback.</i></p>]]></content>
  </entry>
</feed>
