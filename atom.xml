<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title></title>
    <link href="https://boarders.github.io/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2020-12-04T15:08:SZ</updated>
  <author>
      <name>Callan Mcgill</name>
  </author>
  <id>https://boarders.github.io/</id>

  <entry>
      <title>Advent of Code (Days 1-3)</title>
      <link href="https://boarders.github.ioposts/advent1.html"/>
      <id>https://boarders.github.ioposts/advent1.html</id>
      <updated>2020-12-03T00:00:SZ</updated>
      <category term="Haskell"/>
      <category term="Advent of Code"/>
      <summary>Haskell soltuions to Advent Of Code days 1 to 3.</summary>
      <content type="html"><![CDATA[<p>The capacity for humans to suffuse ritual with new meaning is one of life’s great joys. Advent of Code is one such ritual pleasure for me – something that has, in its 5 short years, brightened my holiday season more than any Christmas bauble ever could (though you did try, Rockefeller tree!). I began participating in this particular coding-based ritual around the time that I was giving both programming and Haskell a serious go; this was shortly after unhappily leaving a PhD program that didn’t quite fit. Advent of Code played no small part in both salving my then beleaguered soul and getting to grips with the nuts and bolts that make up so much of what we do as programmers. I would be remiss if I didn’t point out that Advent of Code has redefined my holiday rituals in the best way possible. For this gift I am forever thankful to Advent of Code’s creator Eric Wastl.</p>
<p>I like each year to both aim to get as far as I can through Advent of Code’s 25 puzzles, but also to try to have some wider focus. One year I may take the opportunity to see how far I can get in a new language, another to see how elegant the code I write can be. This year I decided I wanted to concentrate on some mix of Haskell’s algorithmic elegance with reasonably good performance in mind. Here’s how that turned out the first three days:</p>
<h2 id="day-1">Day 1</h2>
<p>Day 1 gave us input consisting of a list of integers as so:</p>
<pre class="terminal"><code>1721
979
366
299
675
1456</code></pre>
<p>In the first puzzle, we were to find the product of the (unique) two integers in the list that sum to 2020. The second called for the product of the three (unqiue) integers that sum to 2020. In general, it is good practice to separate out the proessing of input (parsing) from the algorithm itself. Since we had such constrained input, we stuck with only using a <code>ByteString</code> to read the input. Therefore, our parsing step was as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">ByteString</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parseInput ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>parseInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">&lt;-</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">readFile</span> <span class="st">&quot;input/day1.dat&quot;</span>  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">fst</span> <span class="op">.</span> fromJust <span class="op">.</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">readInt</span>) </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">lines</span> </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> bs</span></code></pre></div>
<p>Here we made use of the <code>readInt</code> function of type <code>readInt :: ByteString -&gt; Maybe (Int, ByteString)</code> and we used an unsafe <code>fromJust</code> since the input consisted of only integers.</p>
<p>I originally started with the elegant but naive quadratic and cubic solutions making use of list comprehensions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sum_2020 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>sum_2020 xs <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span> [ x <span class="op">*</span> y <span class="op">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> <span class="fu">tail</span> xs, x <span class="op">+</span> y <span class="op">==</span> <span class="dv">2020</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">sum3_2020 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>sum3_2020 xs <span class="ot">=</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span> [ x <span class="op">*</span> y <span class="op">*</span> z </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>       <span class="op">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> <span class="fu">tail</span> xs</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>       , z <span class="ot">&lt;-</span> <span class="fu">tail</span> (<span class="fu">tail</span> xs)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>       , x <span class="op">+</span> y <span class="op">+</span> z <span class="op">==</span> <span class="dv">2020</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>       ]</span></code></pre></div>
<p>We could then measure how this performed using criterion as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Criterion.Main</span>  <span class="kw">as</span> <span class="dt">Criterion</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  (bench, bgroup, defaultMain, env, nf)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Day1</span> <span class="kw">as</span> <span class="dt">Day1</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  Criterion.defaultMain <span class="op">.</span> <span class="fu">pure</span> <span class="op">$</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    Criterion.bgroup <span class="st">&quot;advent of code&quot;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    [ Criterion.env Day1.parseInput <span class="op">$</span> \ <span class="op">~</span>d1 <span class="ot">-&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>         Criterion.bgroup <span class="st">&quot;day1&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        [ Criterion.bench <span class="st">&quot;sol1&quot;</span> <span class="op">$</span> </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            Criterion.nf Day1.sum_2020  d1</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        , Criterion.bench <span class="st">&quot;sol2&quot;</span> <span class="op">$</span> </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            Criterion.nf Day1.sum3_2020 d1</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<p>Here we used Criterion’s <code>env</code> function which allowed us to separate out the time spent parsing from the algorithms themselves. The performance of the first solution (on such a small input) was quite reasonable but the cubic performance starts to sting for problem 2:</p>
<pre class="terminal"><code>benchmarking advent of code/day1/sol1
time                 14.96 μs   (14.87 μs .. 15.06 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 14.96 μs   (14.90 μs .. 15.04 μs)
std dev              227.6 ns   (185.3 ns .. 288.1 ns)
variance introduced by outliers: 12% (moderately inflated)

benchmarking advent of code/day1/sol2
time                 7.146 ms   (7.075 ms .. 7.198 ms)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 7.137 ms   (7.091 ms .. 7.192 ms)
std dev              145.2 μs   (110.9 μs .. 213.8 μs)</code></pre>
<p>After some more thought, I reaslised that we could build an <code>IntSet</code> of the entries and then find the first that is the complement of 2020 in each case:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>s1 xs <span class="ot">=</span> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">head</span> [ x <span class="op">*</span> (<span class="dv">2020</span> <span class="op">-</span> x) </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> x <span class="ot">&lt;-</span> xs, (<span class="dv">2020</span> <span class="op">-</span> x) <span class="ot">`IntSet.member`</span> ints</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>         ]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    ints ::</span> <span class="dt">IntSet.IntSet</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    ints <span class="ot">=</span> IntSet.fromList xs</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="ot">s2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>s2 xs <span class="ot">=</span> </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">head</span> [ x <span class="op">*</span> y <span class="op">*</span> (<span class="dv">2020</span> <span class="op">-</span> x <span class="op">-</span> y) </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span> x <span class="ot">&lt;-</span> xs</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>         , y <span class="ot">&lt;-</span> <span class="fu">tail</span> xs</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>         , (<span class="dv">2020</span> <span class="op">-</span> x <span class="op">-</span> y) <span class="ot">`IntSet.member`</span> ints</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>         ]</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="ot">    ints ::</span> <span class="dt">IntSet.IntSet</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    ints <span class="ot">=</span> IntSet.fromList xs</span></code></pre></div>
<p>The performance here was quite a bit better:</p>
<pre class="terminal"><code>benchmarking advent of code/day1/sol1
time                 6.033 μs   (5.961 μs .. 6.144 μs)
                     0.998 R²   (0.995 R² .. 0.999 R²)
mean                 6.070 μs   (5.996 μs .. 6.209 μs)
std dev              301.0 ns   (198.5 ns .. 466.5 ns)
variance introduced by outliers: 61% (severely inflated)

benchmarking advent of code/day1/sol2
time                 86.29 μs   (85.34 μs .. 87.68 μs)
                     0.999 R²   (0.998 R² .. 0.999 R²)
mean                 86.13 μs   (85.36 μs .. 87.13 μs)
std dev              3.090 μs   (2.620 μs .. 3.636 μs)
variance introduced by outliers: 36% (moderately inflated)</code></pre>
<p>At this point there were probably various further improvements we could haved tried, but in the spirit of the season, I grabbed myself a Kinder Surprise and decided that this was a satisfactory place for me to leave things.</p>
<h2 id="day-2">Day 2</h2>
<p>This challenge gave us input data as follows:</p>
<pre class="terminal"><code>1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc</code></pre>
<p>Here we were to read <code>1-3 a</code> as a password policy. The text following the colon can then be read as the given password. Our task was to count the number of passwords from the input that meet the given policy. The first puzzle’s policy, read as <code>1-3 a</code>, states that the password contains between one and three a’s (inclusive). In the second puzzles’s policy, we read the same piece of text, <code>1-3 a</code>, to demand that either of the letters at password positions one or three is an ‘a’, but not both.</p>
<p>In order to get the input, we used <code>attoparsec</code> to parse the policy and password:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Attoparsec.ByteString.Char8</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Range</span> <span class="ot">=</span> <span class="dt">Range</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> low  ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> high ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PassInfo</span> <span class="ot">=</span> <span class="dt">PassInfo</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> passRange ::</span> <span class="op">!</span><span class="dt">Range</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> target    ::</span> <span class="op">!</span><span class="dt">Char</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> password  ::</span> <span class="op">!</span><span class="dt">ByteString</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="ot">parsePassInfo ::</span> <span class="dt">Parser</span> <span class="dt">PassInfo</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>parsePassInfo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  l <span class="ot">&lt;-</span> decimal</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  void <span class="op">$</span> char <span class="ch">&#39;-&#39;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> decimal</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  void <span class="op">$</span> space</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>  tgt <span class="ot">&lt;-</span> anyChar</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  void <span class="op">$</span> char <span class="ch">&#39;:&#39;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  void <span class="op">$</span> space</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  pass <span class="ot">&lt;-</span> takeByteString</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">PassInfo</span> (<span class="dt">Range</span> l h) tgt pass)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="ot">parseInput ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">PassInfo</span>])</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>parseInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">&lt;-</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">readFile</span> <span class="st">&quot;input/day2.dat&quot;</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    input <span class="ot">=</span> </span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>      <span class="fu">traverse</span> (parseOnly parsePassInfo) (<span class="dt">ByteString</span><span class="op">.</span><span class="fu">lines</span> bs)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> input</span></code></pre></div>
<p>For the first part we define a function to count the occurences of a letter using <code>foldl'</code> from <code>Data.ByteString.Char8</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countLetter ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>countLetter bs tgt <span class="ot">=</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">foldl</span> occurs <span class="dv">0</span> bs</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    occurs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    occurs acc c <span class="op">|</span> c <span class="op">==</span> tgt  <span class="ot">=</span> acc <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> acc</span></code></pre></div>
<p>We can then count the number of valid passwords as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">valid1 ::</span> <span class="dt">PassInfo</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>valid1 (<span class="dt">PassInfo</span> (<span class="dt">Range</span> l h) tgt pass) <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> c <span class="ot">=</span> countLetter pass tgt <span class="kw">in</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    (l <span class="op">&lt;=</span> c <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> h)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">PassInfo</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>s1 <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> valid1)</span></code></pre></div>
<p>Part 2 is much the same, only we just need to check the letter only occurs once:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">occursOnce ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>occursOnce bs (<span class="dt">Range</span> l&#39; h&#39;) c <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">`ByteString.index`</span> l <span class="op">==</span> c <span class="op">&amp;&amp;</span> bs <span class="ot">`ByteString.index`</span> h <span class="op">/=</span> c <span class="op">||</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">`ByteString.index`</span> l <span class="op">/=</span> c <span class="op">&amp;&amp;</span> bs <span class="ot">`ByteString.index`</span> h <span class="op">==</span> c</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a> <span class="co">-- go from 1 to 0-indexing </span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    l <span class="ot">=</span> l&#39; <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    h <span class="ot">=</span> h&#39; <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="ot">valid2 ::</span> <span class="dt">PassInfo</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>valid2 (<span class="dt">PassInfo</span> <span class="fu">range</span> tgt pass) <span class="ot">=</span> occursOnce pass <span class="fu">range</span> tgt</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ot">s2 ::</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">PassInfo</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>s2 <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> valid2)</span></code></pre></div>
<p>The performance in both cases here was quite reasonble without further effort and so I didn’t put more time into experimenting with any tweaks here (off for another Kinder sweet):</p>
<pre class="terminal"><code>benchmarking advent of code/day2/sol1
time                 62.30 μs   (61.10 μs .. 63.93 μs)
                     0.996 R²   (0.992 R² .. 0.999 R²)
mean                 63.08 μs   (62.21 μs .. 64.70 μs)
std dev              3.788 μs   (2.581 μs .. 6.136 μs)
variance introduced by outliers: 63% (severely inflated)

benchmarking advent of code/day2/sol2
time                 9.889 μs   (9.668 μs .. 10.11 μs)
                     0.996 R²   (0.993 R² .. 0.998 R²)
mean                 10.07 μs   (9.874 μs .. 10.41 μs)
std dev              887.2 ns   (435.9 ns .. 1.405 μs)
variance introduced by outliers: 83% (severely inflated)</code></pre>
<h2 id="day-3">Day 3</h2>
<p>Day 3 presented us with an ascii map as input:</p>
<pre class="terminal"><code>..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#</code></pre>
<p>We were to view the map as cylindrical in the sense that, as we take any step off the map to the right, we would wind up back on the lefthand side. In the first puzzle we were tasked with traversing the map from top to bottom with each step going one down and three to the right. This started from the top left square. As we did this, we counted the number of ’#’s we encountered.</p>
<p>We parsed the input by splitting it into lines which we could then fold over:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseInput ::</span> <span class="dt">IO</span> [<span class="dt">ByteString</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>parseInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">&lt;-</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">readFile</span> <span class="st">&quot;input/day3.dat&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">lines</span> bs</span></code></pre></div>
<p>The main difficulty here was figuring out the index on a cylindrical map. We created a custom data type for the map’s row length and the size of the step we were taking:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Step</span> <span class="ot">=</span> <span class="dt">Step</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> rowLenS ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> stepS   ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>We then find the cylindrical index as follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findInd ::</span> <span class="dt">Step</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>findInd (<span class="dt">Step</span> rowLen step) row <span class="ot">=</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  row <span class="op">*</span> step <span class="ot">`mod`</span> rowLen</span></code></pre></div>
<p>Since we were on a cylindrical map, we needed to take the product of the row and the stride length modulo the row length. We could then count the ‘#’’s we see:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrees ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>countTrees step bss <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">snd</span> <span class="op">.</span> foldl&#39; c (<span class="dv">0</span>, <span class="dv">0</span>) <span class="op">$</span> bss</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    rowLen <span class="ot">=</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">length</span> <span class="op">.</span> <span class="fu">head</span> <span class="op">$</span> bss</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    st <span class="ot">=</span> <span class="dt">Step</span> rowLen step</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    c ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    c (row, count) bs <span class="ot">=</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>       ( row <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>       , count <span class="op">+</span> <span class="fu">fromEnum</span> (bs <span class="ot">`index`</span> findInd st row <span class="op">==</span> <span class="ch">&#39;#&#39;</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> [<span class="dt">ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>s1 <span class="ot">=</span> countTrees <span class="dv">3</span></span></code></pre></div>
<p>Here we again used <code>foldl'</code> (this time over lists) and added to the count if the character at the cylindrical index was a ‘#’.</p>
<p>For the second part, we were asked to do the same task only this time using: paths going down 1 and to the right 1, 3, 5 and 7 respectively; and a path going down 2 and along 1. Since my fold wasn’t well equipped for skipping between rows, I decided to hackily copy and paste what I already had for the last case:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrees2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>countTrees2 step bss <span class="ot">=</span> </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    (\(_,_,cnt) <span class="ot">-&gt;</span> cnt) <span class="op">.</span> foldl&#39; c (<span class="dt">True</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="op">$</span> bss</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    rowLen <span class="ot">=</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">length</span> <span class="op">.</span> <span class="fu">head</span> <span class="op">$</span> bss</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    st <span class="ot">=</span> <span class="dt">Step</span> rowLen step</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    c ::</span> (<span class="dt">Bool</span>, <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    c (alt, jump, count) bs <span class="ot">=</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> alt</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>          ( <span class="fu">not</span> alt</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>          , jump <span class="op">+</span> <span class="dv">1</span> </span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>          , count <span class="op">+</span> <span class="fu">fromEnum</span> (bs <span class="ot">`index`</span> findInd st jump <span class="op">==</span> <span class="ch">&#39;#&#39;</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>          (<span class="fu">not</span> alt, jump, count)</span></code></pre></div>
<p>In the accumulator we kept track of a boolean which we alternated for those rows we wished to count versus those we were skipping. The second puzzle then asked us to multiply all of these together which we did as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">s2 ::</span> [<span class="dt">ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>s2 input <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">product</span> <span class="op">.</span> <span class="fu">map</span> (\i <span class="ot">-&gt;</span> countTrees i input) <span class="op">$</span> [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>]) </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span> countTrees2 <span class="dv">1</span> input</span></code></pre></div>
<p>The performance here was also reasonable on the first try, and so again I didn’t put any further efforts into doing better, this time trading my keyboard for two Kinder bonbons:</p>
<pre class="terminal"><code>
benchmarking advent of code/day3/sol1
time                 5.614 μs   (5.585 μs .. 5.647 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 5.660 μs   (5.623 μs .. 5.700 μs)
std dev              130.4 ns   (102.9 ns .. 173.3 ns)
variance introduced by outliers: 26% (moderately inflated)

benchmarking advent of code/day3/sol2
time                 24.18 μs   (23.99 μs .. 24.36 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 24.17 μs   (24.07 μs .. 24.30 μs)
std dev              374.4 ns   (304.0 ns .. 496.4 ns)
variance introduced by outliers: 12% (moderately inflated)</code></pre>
<p>Thank you for reading! The full code for this post is available <a href="https://github.com/Boarders/advent-of-code/tree/master/2020">here</a>. Please feel free to contact me <a href="mailto:callan.mcgill@gmail.com">here</a> with questions, thoughts, ideas, or all of the above.</p>
<p><i>With warmest thanks to Alixandra Prybyla for their valuable feedback.</i></p>]]></content>
  </entry>
  <entry>
      <title>Locally Nameless</title>
      <link href="https://boarders.github.ioposts/locally-nameless.html"/>
      <id>https://boarders.github.ioposts/locally-nameless.html</id>
      <updated>2019-10-27T00:00:SZ</updated>
      <category term="Type theory"/>
      <category term="Lambda Calculus"/>
      <summary>The locally nameless approach to substitution.</summary>
      <content type="html"><![CDATA[<p>The untyped lambda calculus has a very simple grammar with just three term formers: <span class="math inline">\(\def\sp{\mspace{5mu}}\)</span></p>
<p><span class="math display">\[ \mathrm{term}
 \mathrel{\vcenter{\hbox{::}}{=}} v \sp
  | \sp \lambda \sp v \sp . \sp \mathrm{term} \sp
  | \sp \mathrm{term} \sp \mathrm{term} \sp
  \]</span></p>
<p>Or in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lam</span> a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span></code></pre></div>
<p>In order that this work as a theory of computation, we need some notion of evaluation and this is driven by <span class="math inline">\(\beta\)</span>-reduction. The standard jargon in lambda caluclus is to say that a <span class="math inline">\(\beta\)</span>-redex is any subterm of the form <span class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}\)</span>. On such a <span class="math inline">\(\beta\)</span>-redex we can then step via (capture-avoiding) substitution:</p>
<p><span class="math display">\[ (\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}
    \rightsquigarrow
   f\sp[x  \mathrel{\vcenter{\hbox{:}}{=}} \mathrm{arg}]
  \]</span></p>
<p>Formally we then extend this to a congruence relation on Lambda terms via rules of the form:</p>
<p><span class="math display">\[
  M \rightsquigarrow M&#39; \Rightarrow M N \rightsquigarrow M&#39; N
\]</span> <span class="math display">\[
  N \rightsquigarrow N&#39; \Rightarrow M N \rightsquigarrow M  N&#39;
  \]</span></p>
<p>Precisely how we choose to set up these rules to give a computational semantics to our language corresponds algorithmically to a choice of evaluation strategy. As such, this opens up myriad interesting questions related to order of evaluation and normal forms and so on. Instead we will largely bypass these considerations and concentrate on the more humdrum (but no less vital) matter of the practicalities of performing such capture-avoiding substitutions. The basic problem with too naive an approach is as follows:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp \lambda \sp y \sp . \sp  x) \sp \mathrm{y}
    \rightsquigarrow
   (\lambda \mathrm{y} \sp . \sp y)
  \]</span></p>
<p>Here we have substituted the <em>free</em> variable y into our lambda term and it has become <em>bound</em>. This is semantically incorrect: the names of free variables are meaningful because, in spirit, they refer to names we have defined elsewhere (that is, they can be looked up within a context, or, in other words, they are <em>open</em> for further substitution). Conversely, the names of bound variables are, computationally speaking, unimportant. In fact, it is usual to refer to the grammar we have introduced earlier as <em>pre-lambda terms</em> and to take lambda terms as referring to the equivalence classes under <span class="math inline">\(\alpha\)</span>-equivalence. This refers to the (equivalence) relation whereby two terms are equivalent if we can consistently rename the bound variables of one to obtain the other (here too we need to take care, <span class="math inline">\(\alpha\)</span>-renaming <span class="math inline">\(\mathrm{x}\)</span> to <span class="math inline">\(\mathrm{y}\)</span> in the above term would lead to a different sort of variable capture). Most accounts of <span class="math inline">\(\alpha\)</span>-equivalence are themselves intimiately tied up with the question of how to perform substitution (and locally nameless is no different in this respect).</p>
<p>In practice this means that in order to compute <span class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}\)</span> we would first <span class="math inline">\(\alpha\)</span>-rename <span class="math inline">\(\mathrm{x}\)</span> to a variable that is neither already named within <span class="math inline">\(\mathrm{f}\)</span>, nor appears free within <span class="math inline">\(\mathrm{arg}\)</span>. Carrying out such a procedure by brute force is workable, but tends to be rather error-prone. A straightforward approach along these lines is described in <a href="http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html">this excellent post</a> by Lennart Augustsson.</p>
<p>There are a <a href="https://www.schoolofhaskell.com/user/edwardk/bound">whole host</a> of more sophisticated methods for dealing with the problem of capture-avoiding substitution. Perhaps one of the best known is to use De-Bruijn indices. The idea here is to replace all bound variables by a natural number. This indicates the variable’s distance from its binding site. All free variables are then represented by distinct natural numbers greater than the maximum depth of any binding site in the term. We then keep track of these variables within the environment under which computation is performed. For instance, the following is how one might translate a typical term into De-Bruijn indices:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp \lambda \sp y \sp . \sp  x \sp z)
    \longrightarrow
   (\lambda \sp \lambda \sp . \sp 1 \sp 3 )
   \]</span> <span class="math display">\[
   [z \mapsto 3]
  \]</span></p>
<p>Here we keep both the translated lambda term but also the context for how to read free variables.</p>
<p>This approach offers two key advantages:</p>
<ul>
<li>Capture avoiding substitution becomes a matter of keeping binding distance arithmetic in check.</li>
<li>The De-Bruijn representation gives canonical representatives for <span class="math inline">\(\alpha\)</span>-equivalence classes, thus allowing us to test for <span class="math inline">\(\alpha\)</span>-equivalence via syntactic equality of terms.</li>
</ul>
<p>On the other hand, Bob Atkey has, rather aptly, referred to the ability to read terms written with DeBruijn indices as a “cylon detector”. What we gain in ease of implementation we give up in much worse readability.</p>
<p>Instead we turn to the hybrid approach in the paper <a href="http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">I Am Not a Number – I am a Free Variable</a>. Let us keep free variables free and use De-Bruijn indices only for bound variables:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Our variable type keeps the old free variables and uses</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">--integers to represent bound variables.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Var</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">F</span> a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">B</span> <span class="dt">Int</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Locally nameless terms will be the same lambda terms with</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- variables now labelled either bound or free.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LocallyNameless</span> a <span class="ot">=</span> <span class="dt">Lam</span> (<span class="dt">Var</span> a)</span></code></pre></div>
<p>Notice how, because we use the same lambda terms with this representation, we still have names at binders. This is useful as we can recover the named term we started out with, carrying along all such names as we perform work. Here is how we convert between the two representations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase          #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">toLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>toLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Var</span> a  <span class="ot">-&gt;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- we check if our variable has been bound elsewhere</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> a <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> bv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> a)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- As we have gone under a binder we bump each variable</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- by 1, inserting our newly bound variable at 0.</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>          env&#39; <span class="ot">=</span> insert n <span class="dv">0</span> (M.map (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Lam</span> (<span class="dt">F</span> n) (go env&#39; e)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>fromLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Map</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Var</span> v <span class="ot">-&gt;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> v <span class="kw">of</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>          <span class="dt">F</span> a  <span class="ot">-&gt;</span> <span class="dt">Var</span> a</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>               <span class="co">-- we look up our bound variable with the name we collected from</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>               <span class="co">-- its binder</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="kw">case</span> bv <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> name</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;Found bound variable :&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv <span class="op">&lt;&gt;</span> <span class="st">&quot; without binder.&quot;</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- if our lambda term has a Bound variable at a binding site something</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- has gone horribly wrong</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Found unnamed variable at binding site&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>          <span class="dt">F</span> v  <span class="ot">-&gt;</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>           <span class="co">-- We store the name of the binder in the environment</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>              env&#39; <span class="ot">=</span> insert <span class="dv">0</span> v (mapKeysMonotonic (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Lam</span> v (go env&#39; e)</span></code></pre></div>
<p>Now let’s see that this works as expected (this is, for me, a worrying amount of bookeeping to leave to “Looks good!”). Let us use quickcheck to see that <strong>fromLocallyNameless</strong> is a left inverse to <strong>toLocallyNameless</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- We use a somewhat unprincipled approach to generating arbitrary terms</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- but for our purposes it will do the job.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Lam</span> a) <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>      buildTerm i</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">      buildTerm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Term</span> a)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      buildTerm i</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">2</span>    <span class="ot">=</span> arbitrary <span class="op">&gt;&gt;=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">Var</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">8</span>    <span class="ot">=</span> <span class="dt">Lam</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- so that our terms don&#39;t explode we limit</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- the amount of branching we allow</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">App</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- fromLocalyNameless is a left inverse to toLocallyNameless.</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLocallyNamelessLeftInverse ::</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>fromLocallyNamelessLeftInverse e <span class="ot">=</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  (fromLocallyNameless <span class="op">.</span> toLocallyNameless) e <span class="op">===</span> e</span></code></pre></div>
<p>Thankfully, this does indeed work as expected:</p>
<pre class="shell"><code>Tests
  Property Tests
    fromLocallyNameless ∘ toLocallyNameless == id: OK (0.35s)
      +++ OK, passed 1000 tests.</code></pre>
<p>Now that we have terms in locally nameless representation, we can perform substitution in a fairly straightforward manner. In the McBride–McKinna (MM) paper, they refer to this operation as <strong>“instantiate”</strong>. It is also common in the locally nameless literature to call the operation <strong>“opening”</strong> or <strong>“open”</strong> because it involves opening the body of a term to substitute for its outermost bound variable. As this accords with our intuitions on the meaning of substitution of locally nameless terms, we will follow this convention.</p>
<p>Note that in the code below, we follow (at least in spirit) the MM approach of using a scope type to denote a term that is only legal as the body of an expression (i.e. a term which may have bound variables referring to a non-existant outer binder such as <span class="math inline">\(\lambda \sp . \sp 1\)</span>). In our case, we only use a type synonym; however, in a more substantial implementation, one should use a newtype to get the type safety that such a measure confers.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Scope</span> f x <span class="ot">=</span> f x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- ┌─── term we are substituting</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- │</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- │                 ┌─── body we are substituting into</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- │                 │</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- │                 │</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">open ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Scope</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>open image <span class="ot">=</span> go <span class="dv">0</span> <span class="co">-- the bound variable begins at 0</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    go outer <span class="ot">=</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      \<span class="kw">case</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Var</span> fbv <span class="ot">-&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> fbv <span class="kw">of</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- if the bound variable refers to the outer binder of the body</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- of the term then we substitute the image.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">B</span> bv <span class="op">|</span> bv <span class="op">==</span> outer <span class="ot">-&gt;</span> image</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">F</span> fv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> fv)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go outer l) (go outer r)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- Note that as we have gone under another binder we must</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- in turn bump the binding variable we substitute for</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">-- so that it still refers to the outermost binder.</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Lam</span> n b <span class="ot">-&gt;</span> <span class="dt">Lam</span> n (go (outer <span class="op">+</span> <span class="dv">1</span>) b)</span></code></pre></div>
<p>From here it is easy for us to implement reduction to both normal form and weak-head normal form (where we use call-by-name semantics). We will, in both cases, write a function that does all of the work using locally nameless terms and functions that make use of that work on named lambda terms via the previously defined conversion functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">whnfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>whnfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- ┌─── current leftmost lambda term</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- │</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- │             ┌─── list of collected arguments</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- │             │</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- │             │</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- if we encounter an application then we collect the</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- argument on the right and recurse into the left term</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- We only perform substitution if we have both</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- a non-empty list of arguments to substitute and</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- a leftmost lambda term.</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Note that we substitute the body before evaluation</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- and hence we follow call-by-name semantics.</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        _</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- otherwise we encountered no further leftmost</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- lambda terms and so we re-apply App to the</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- built-up list of arguments</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t as</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="ot">whnf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- defer the work to the locally nameless terms</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>whnf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> whnfLN <span class="op">.</span> toLocallyNameless</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="ot">nfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>nfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- the same as above we collect right arguments in a list.</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- If we have no arguments to apply to a lambda then we</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- recurse into the body (this is the difference between</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- normal form and weak head normal form).</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> n body) , [])</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> (<span class="dt">Lam</span> n (nfLN body))</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        _</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- If we encounter no further lambdas then we reduce </span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- each of our built-up arguments before re-applying App.</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t (<span class="fu">fmap</span> nfLN as)</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a><span class="ot">nf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- again we defer all the actual work to locally nameless terms.</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>nf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> nfLN <span class="op">.</span> toLocallyNameless</span></code></pre></div>
<p>Now that we have written this reduction code, we should test it. But what on? A natural choice is to consider church encodings of the natural numbers. Since all we have in the lambda calculus is a theory of functions (with no base data types), we must encode any data in the form of functions. Church numerals act as a prototypical example of such an encoding:</p>
<p><span class="math display">\[ \mathrm{zero} = \lambda \sp \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{z} \]</span> <span class="math display">\[ \mathrm{succ}\sp \mathrm{n} = \lambda \sp \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{s} \sp (\mathrm{n} \sp \mathrm{s} \sp \mathrm{z}) \]</span></p>
<p>The idea here is that zero takes as arguments a step function <span class="math inline">\(\mathrm{s}\)</span> and a starting value <span class="math inline">\(\mathrm{z}\)</span>, returning the starting value. A positive number n, on the other hand, takes those arguments and applies the step function to the starting value n times. Here is what this looks like using our named terms:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- [...]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- We give ourselves some handy infix syntax for apply.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">.$</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.$) ::</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">.$</span>) <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- The unary natural numbers.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Notice here in the inductive case we reduce to normal form. </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not doing so leads to a subtly different term wherein we </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- are applying &quot;S&quot; to a term that itself is a lambda term</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- applied to two arguments but not yet β-reduced.</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fromNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>fromNat <span class="dt">Z</span>     <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> <span class="st">&quot;Z&quot;</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>fromNat (<span class="dt">S</span> n) <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;S&quot;</span> <span class="op">.$</span> (nf <span class="op">$</span> fromNat n <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Let us also give ourselves names for the first </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- few church numerals for convenience:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>cZero  <span class="ot">=</span> fromNat <span class="dt">Z</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>cOne   <span class="ot">=</span> fromNat (<span class="dt">S</span> <span class="dt">Z</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>cTwo   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>cThree <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>cFour  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>cFive  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))))</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>cSix   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))))</span></code></pre></div>
<p>Now recall that we wish to test how our code <em>evaluates</em> to normal form and thus we should consider some functions to actually run. Two such functions that come to mind are addition and multiplication. But how are these defined for Church numerals? Remember that <span class="math inline">\(\mathrm{n}\)</span> is meant to represent applying a step function <span class="math inline">\(\mathrm{n}\)</span> times to a value. If the value we apply to the step function is the result of applying a step function argument <span class="math inline">\(\mathrm{s}\)</span> to a starting value <span class="math inline">\(\mathrm{m}\)</span> times, we see that this is operationally the same as <span class="math inline">\(\mathrm{m} + \mathrm{n}\)</span>. In lambda terms:</p>
<p><span class="math display">\[ \mathrm{add} := \lambda \mathrm{n} \sp . \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp \mathrm{s} \sp (\mathrm{m} \sp  \mathrm{s} \sp \mathrm{z} )
  \]</span></p>
<p>Similarly, we can define multiplication of <span class="math inline">\(\mathrm{m}\)</span> by <span class="math inline">\(\mathrm{n}\)</span> by applying <span class="math inline">\(\mathrm{n}\)</span> to the step funtion <span class="math inline">\((\mathrm{m} \sp s)\)</span> (the <span class="math inline">\(\mathrm{m}\)</span>-fold application of <span class="math inline">\(\mathrm{s}\)</span>) and starting value <span class="math inline">\(\mathrm{z}\)</span>:</p>
<p><span class="math display">\[ \mathrm{mult}:= \lambda \mathrm{n} \sp . \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp (\mathrm{m} \sp \mathrm{s}) \sp z
  \]</span></p>
<p>Let us translate this into Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">churchAdd ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>churchAdd <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> ((<span class="dt">App</span> <span class="st">&quot;n&quot;</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">churchMult ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>churchMult <span class="ot">=</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;n&quot;</span> <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>))))</span></code></pre></div>
<p>As a first check let us see that <span class="math inline">\(2 + 2 \rightsquigarrow 4\)</span> and that <span class="math inline">\(2 * 3 \rightsquigarrow 6\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span>      <span class="kw">as</span> <span class="dt">HU</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- [...]</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">unitTests ::</span> <span class="dt">TestTree</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>unitTests <span class="ot">=</span> testGroup <span class="st">&quot;Church Arithmetic Unit Tests&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  [ HU.testCase</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;2 + 2 ⇝ 4&quot;</span> <span class="op">$</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      (nf <span class="op">$</span> (churchAdd <span class="op">.$</span> cTwo) <span class="op">.$</span> cTwo) <span class="op">@?=</span> cFour</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  , HU.testCase</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;2 * 3 ⇝ 6&quot;</span> <span class="op">$</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      (nf <span class="op">$</span> churchMult <span class="op">.$</span> cTwo <span class="op">.$</span> cThree) <span class="op">@?=</span> cSix</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>This is fortunately the case:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Church</span> Arithmetic Unit Tests</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">2</span> + 2 ⇝ 4:                         OK</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">2</span> <span class="pp">*</span> 3 ⇝ 6:                         OK</span></code></pre></div>
<p>For a slightly more robust test, we can also write property tests to check that addition and multiplication are each commutative. First we will want to have an arbitrary instance for our definition of the unary natural numbers:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInt</span> n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInt</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- We convert from a randomly generated integer</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- between 0 and 50.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    arbitrary <span class="ot">=</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">50</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="op">$</span> <span class="fu">fromInt</span> i</span></code></pre></div>
<p>Now we can write our properties as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">[...]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">additionIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>additionIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      nf (churchAdd <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">===</span> nf (churchAdd <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">multiplicationIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>multiplicationIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>      nf (churchMult <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">===</span> nf (churchMult <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="ot">churchProperties ::</span> [<span class="dt">TestTree</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>churchProperties <span class="ot">=</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  [ QC.testProperty</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Addition of Church numerals is commutative&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>     (withMaxSuccess <span class="dv">100</span> additionIsCommutative)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  , QC.testProperty</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Multiplication of Church numerals is commutative&quot;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>     (withMaxSuccess <span class="dv">100</span> multiplicationIsCommutative)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>Running this gives us the following:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Addition</span> of Church numerals is commutative:       OK <span class="er">(</span><span class="ex">0.05s</span><span class="kw">)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Multiplication</span> of Church numerals is commutative: OK <span class="er">(</span><span class="ex">0.07s</span><span class="kw">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>It looks like our implementation might be (close to) working as hoped! Phew.</p>
<p>We should note that one downside to our version of locally nameless terms is that there are syntacticaly valid terms in our grammar which, nevertheless, do not make sense as lambda terms. For example, the following term is perfectly valid in our grammar: <span class="math display">\[
    \lambda \sp . \sp \lambda \sp . \sp (1 \sp 3)
  \]</span></p>
<p>Here there is a bound variable <span class="math inline">\(3\)</span> but the binding depth is only 1 (counting from <span class="math inline">\(0\)</span>). We would like, instead, to use the type system to enforce that each of our terms is (intrinsically) a valid lambda term. Doing this in Haskell is quite a challenge as such an endeavour necessarily involves types which keep track of the maximum current binding variable, and thus dependent types. In our next post we will see how to do this in Agda and then prove various properties of our locally nameless terms.</p>
<p>Thank you for reading! Feel free to contact me <a href="mailto:callan.mcgill@gmail.com">here</a> with questions, thoughts, ideas, or all of the above.</p>]]></content>
  </entry>
  <entry>
      <title>On Characterizing Nat in Agda</title>
      <link href="https://boarders.github.ioposts/peano.html"/>
      <id>https://boarders.github.ioposts/peano.html</id>
      <updated>2020-10-06T00:00:SZ</updated>
      <category term="Agda"/>
      <category term="Natural Numbers"/>
      <summary>Explorations into characterizing natural numbers</summary>
      <content type="html"><![CDATA[<p>The 19th century brought about an unprecedented revolution in the foundations of mathematics culminating in the Zermelo–Frankel (ZF) axioms. The ZF axioms gave a logical basis to Cantor’s <em>set theory</em> as a foundational theory, in which the main branches of mathematics (analysis, topology, geometry and number theory) could be encoded and thusly understood. It was through this newly-systematized approach that the axiomatic method was born. This is of historical and philosophical interest as it marks a decisive structuralist turn in mathematical thought. It is at this time that mathematical objects begin to be characterized not by any particular construction, but by the collection of axioms (or laws) an object satisfies. <span class="math inline">\(\def\N{\mathsf{N}}\)</span></p>
<p>Consider a paradigmatic case: characterizing the natural numbers. In this post we will explore two different formulations of the natural numbers, the first of which is given by Peano in the late 19th century, and the second of which is a more categorical approach inspired by Lawvere. This will provide us a springboard upon which to explore <em>how</em> we can formulate and reason about mathematical structures in Agda. Since Agda is based on dependent type theory, our formulations will be <a href="https://en.wikipedia.org/wiki/Constructivism_(philosophy_of_mathematics)"><em>constructive</em></a>. This means our constructions will be <em>proof relevant</em>. In this setting, proofs are first-class entities and as such our algebraic structures will encode both the operations a structure has along with proofs of the properties that it satisfies.</p>
<p>We will assume the reader has some familiarity with Agda (with relevant materials noted throughout) and has an interest in formalizing mathematics.</p>
<p>Let us begin with Peano’s axioms. A set <span class="math inline">\(\N\)</span> satisfies Peano’s axioms if the following properties hold:</p>
<ul>
<li>There exist terms <span class="math inline">\(0 \in \N\)</span> and <span class="math inline">\(\mathrm{s} : \N \rightarrow \N\)</span>.</li>
<li><span class="math inline">\(\N\)</span> carries an equivalence relation <span class="math inline">\(\simeq\;\subset\N \times\N\)</span> (to be explained below).</li>
<li><span class="math inline">\(\mathrm{s}\)</span> reflects <span class="math inline">\(\simeq\)</span>-equivalence: <span class="math display">\[ \forall \; \mathrm{n}, \mathrm{m} \in \N \; . \; \mathrm{s} (\mathrm{n}) \simeq \mathrm{s} (\mathrm{m}) \Rightarrow \mathrm{m} \simeq \mathrm{n} \]</span></li>
<li><span class="math inline">\(0\)</span> is never (equivalent to) the successor of any number: <span class="math display">\[ \nexists \; \mathrm{n} \in \mathbb{N} \; . \; \mathrm{s}(n) \simeq 0 \]</span></li>
<li><span class="math inline">\(\N\)</span> satisfies induction: if <span class="math inline">\(\phi : \N \rightarrow \mathbb{B}\)</span> is a predicate and the following conditions hold:
<ul>
<li><span class="math inline">\(\phi(0)\)</span> is true.</li>
<li><span class="math inline">\(\forall \; \mathrm{n} \in \mathbb{N} \; . \; \phi(n) \Rightarrow \phi(\mathrm{s}(\mathrm{n}))\)</span></li>
</ul>
then <span class="math inline">\(\phi\)</span> is true for all <span class="math inline">\(\mathrm{n} \in \N\)</span>.</li>
</ul>
<p>How can we prove that this uniquely determines the natural numbers? Our strategy would go roughly as follows:</p>
<ul>
<li>Give a particular construction of <span class="math inline">\(\mathbb{N}\)</span> showing it satisfies the axioms.</li>
<li>For any set <span class="math inline">\(\N\)</span> satisfying the axioms, construct maps: <span class="math display">\[\begin{aligned}
  \mathrm{from} &amp;: \mathbb{N} \rightarrow \mathsf{N} \\
  \mathrm{to}   &amp;: \mathsf{N} \rightarrow \mathbb{N} \\
\end{aligned}\]</span></li>
<li>Use induction with the following predicates: <span class="math display">\[\begin{aligned}
  \phi_{\mathbb{N}}(n) &amp;= n \simeq_\mathbb{N} \mathrm{to} \circ \mathrm{from}(n) \\
  \phi_{\mathsf{N}}(n) &amp;= n \simeq_\mathsf{N} \mathrm{to} \circ \mathrm{from} (n)
\end{aligned}\]</span> to show the these maps form an equivalence.</li>
</ul>
<p>Let’s try to formalise this constructively in Agda. We start with a few imports we will need later:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Peano <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>PropositionalEquality</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>≡<span class="ot">_;</span> refl<span class="ot">;</span> <span class="ot">_</span>≢<span class="ot">_;</span> cong<span class="ot">;</span> trans<span class="ot">;</span> sym<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Function</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="ot">(_</span>∘<span class="ot">_)</span></span></code></pre></div>
<p>Typically, we define the (unary) natural numbers as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  Zero <span class="ot">:</span> ℕ</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  Succ <span class="ot">:</span> ℕ <span class="ot">-&gt;</span> ℕ</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">{-# BUILTIN NATURAL ℕ #-}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- This allows us to use numeric literals.</span></span></code></pre></div>
<p>Our first port of call is to formulate equivalence relations. In Agda we usually encode algebraic structures as <a href="https://agda.readthedocs.io/en/v2.6.1.1/language/record-types.html">records</a>. As mentioned in the introduction, since proofs are first-class, we carry around not just the structure of the binary relation but also the properties it satisfies:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> EqRel <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Set₁ <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>≃<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    reflexivity  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a <span class="ot">:</span> A<span class="ot">}</span>     <span class="ot">→</span> a ≃ a</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    symmetry     <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span>   <span class="ot">→</span> a ≃ b <span class="ot">→</span> b ≃ a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    transitivity <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b c <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> a ≃ b <span class="ot">→</span> b ≃ c <span class="ot">→</span> a ≃ c</span></code></pre></div>
<p>We note that this definition is slightly different from what is typical in mathematics. Rather than a <em>subset</em> of the diagonal, we make use of a two-argument dependent type <span class="math inline">\(\_ \simeq \_\)</span>. Given <span class="math inline">\(\mathrm{a}, \mathrm{b} : \mathrm{A}\)</span>, the type <span class="math inline">\(\mathrm{a}\;\simeq\;\mathrm{b}\)</span> gives the collection of <em>evidence</em> that <span class="math inline">\(\mathrm{a}\)</span> and <span class="math inline">\(\mathrm{b}\)</span> are equal. The axioms this satisfies are reflexivity (that any element is equal to itself) symmetry (that we can freely reverse equalities) and transitivity (that we can compose equalities).</p>
<p>Let’s show that Agda’s built-in equality type, <span class="math inline">\(\equiv\)</span>, is an equivalence relation on <span class="math inline">\(\mathbb{N}\)</span>. As a brief reminder, here is how the equality type is defined, if we ignore <a href="https://agda.readthedocs.io/en/v2.6.1.1/language/universe-levels.html">level polymorphism</a>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  refl <span class="ot">:</span> x ≡ x</span></code></pre></div>
<p>That is to say, we can give a term <span class="math inline">\(\mathrm{refl}\)</span> of type <span class="math inline">\(\mathrm{a} \equiv \mathrm{b}\)</span> so long as Agda can directly compute that <span class="math inline">\(\mathrm{a}\)</span> and <span class="math inline">\(\mathrm{b}\)</span> are equal within the particular context. For example, if we define addition:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">-&gt;</span> ℕ <span class="ot">-&gt;</span> ℕ</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> Zero     m <span class="ot">=</span> m</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">(</span>Succ n<span class="ot">)</span> m <span class="ot">=</span> Succ <span class="ot">(</span>n + m<span class="ot">)</span></span></code></pre></div>
<p>then we can give the following (unnamed) definition:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> <span class="ot">:</span> <span class="dv">2</span> + <span class="dv">2</span> ≡ <span class="dv">4</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>as Agda can compute that both sides are equal.</p>
<p>Coming back to <span class="math inline">\(\mathbb{N}\)</span>, let’s show how <span class="math inline">\(\equiv\)</span> satisfies the properties of an equivalence relation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ℕ-refl <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> n ≡ n</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ℕ-refl <span class="ot">=</span> refl</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ℕ-symm <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> n ≡ m <span class="ot">→</span> m ≡ n</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ℕ-symm n≡m <span class="kw">rewrite</span> n≡m <span class="ot">=</span> refl</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>ℕ-trans <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n r <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> m ≡ n <span class="ot">→</span> n ≡ r <span class="ot">→</span> m ≡ r</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>ℕ-trans  m≡n n≡r <span class="kw">rewrite</span> m≡n <span class="ot">|</span> n≡r <span class="ot">=</span> refl</span></code></pre></div>
<p>Here we make use of Agda’s <a href="https://agda.readthedocs.io/en/v2.6.1/language/with-abstraction.html#with-rewrite">rewrite construction</a>. By providing an equality proof of the form <span class="math inline">\(\mathrm{a} \equiv \mathrm{b}\)</span>, the rewrite construction will replace subexpressions in the goal of the form <span class="math inline">\(\mathrm{a}\)</span> with <span class="math inline">\(\mathrm{b}\)</span>. For example, in <span class="math inline">\(\mathbb{N}\mathrm{-symm}\)</span>, we use the equality term we are given, <span class="math inline">\(\mathrm{n} \equiv \mathrm{m}\)</span>, as an argument to rewrite so that each appearance of <span class="math inline">\(\mathrm{n}\)</span> is replaced with <span class="math inline">\(\mathrm{m}\)</span>. At this point we may fill the hole with <span class="math inline">\(\mathrm{refl} : \mathrm{m} \equiv \mathrm{m}\)</span>.</p>
<p>It is worth noting that we haven’t used anything special about <span class="math inline">\(\mathbb{N}\)</span> and these same definitions would work to prove that <em>any</em> set forms an equivalence relation under <span class="math inline">\(\equiv\)</span>.</p>
<p>Now we can write an instance of EqRel for <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> EqRel <span class="ot">{{...}}</span> <span class="kw">public</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  ≡-Nat <span class="ot">:</span> EqRel ℕ</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  ≡-Nat <span class="ot">=</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">record</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{</span> <span class="ot">_</span>≃<span class="ot">_</span>          <span class="ot">=</span> <span class="ot">_</span>≡<span class="ot">_</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> reflexivity  <span class="ot">=</span> ℕ-refl</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> symmetry     <span class="ot">=</span> ℕ-symm</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> transitivity <span class="ot">=</span> ℕ-trans</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">}</span></span></code></pre></div>
<p>Here we use Agda’s <a href="https://agda.readthedocs.io/en/v2.6.1.1/language/instance-arguments.html">instance arguments</a> mechanism, the analog to Haskell’s typeclass instances. We start by bringing the fields of EqRel into scope for those instances which can be resolved. This is essentially equivalent to us defining top-level functions of the form:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>≃<span class="ot">_</span>         <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">→</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>reflexivity <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>a ≃ a<span class="ot">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>Implicit arguments <span class="math inline">\(\{\{\_ : \mathrm{EqRel}\; \mathrm{A}\}\}\)</span> are resolved by searching for instances we have available in scope. In particular, we define an instance of EqRel for <span class="math inline">\(\mathbb{N}\)</span> which means that we may use these methods on <span class="math inline">\(\mathbb{N}\)</span> and Agda will infer the instance we have provided.</p>
<p>Now we are in a position to formalise the Peano axioms. In much the same way as we have done with equivalence relations, we again use records to encode algebraic structure:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Peano <span class="ot">(</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">{{</span>rel <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">:</span> Set₁ <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    zero        <span class="ot">:</span> N</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    succ        <span class="ot">:</span> N <span class="ot">→</span> N</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    s-injective <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>succ a<span class="ot">)</span> ≃ <span class="ot">(</span>succ b<span class="ot">)</span> <span class="ot">→</span> a ≃ b</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    zero≠succ   <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span> <span class="ot">→</span> zero ≃ <span class="ot">(</span>succ a<span class="ot">)</span> <span class="ot">→</span> ⊥</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    induction   <span class="ot">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>       <span class="ot">∀</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>z <span class="ot">:</span> P zero<span class="ot">)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">→</span> P b <span class="ot">→</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> P a</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    induction-zero <span class="ot">:</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>       <span class="ot">∀</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>z <span class="ot">:</span> P zero<span class="ot">)</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">→</span> P b <span class="ot">→</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>induction P zero z s ≡ z<span class="ot">)</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    induction-succ <span class="ot">:</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>       <span class="ot">∀</span> <span class="ot">(</span>P <span class="ot">:</span> N <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>z <span class="ot">:</span> <span class="ot">(</span>P zero<span class="ot">))</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>s <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">→</span> P b <span class="ot">→</span> P <span class="ot">(</span>succ b<span class="ot">))</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>       <span class="ot">→</span> <span class="ot">(</span>induction P <span class="ot">(</span>succ a<span class="ot">)</span> z s ≡ s <span class="ot">(</span>induction P a z s<span class="ot">))</span></span></code></pre></div>
<p>Several things are worth noting about this defintion:</p>
<ul>
<li>We again make use of instance arguments so that the input type <span class="math inline">\(\N\)</span> has the structure of an equivalence relation. This is somewhat similar to a typeclass extension definition in Haskell:</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a</span></code></pre></div>
<ul>
<li>We upgrade induction from a unary predicate <span class="math inline">\(\phi : \N \rightarrow \mathbb{B}\)</span> to a dependent type <span class="math inline">\(\mathrm{P} : \N \rightarrow \mathrm{Set}\)</span>.</li>
<li>As we will see later, we would like this upgraded principle to be able to <em>compute</em>. As such we add two laws that dictate how computation should unfold.</li>
</ul>
<p>Let’s now prove that <span class="math inline">\(\mathbb{N}\)</span> satisfies induction and injectivity of <span class="math inline">\(\mathrm{Succ}\)</span>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ℕ-induction <span class="ot">:</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">(</span>P <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>a <span class="ot">:</span> ℕ<span class="ot">)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>P Zero<span class="ot">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(∀</span> <span class="ot">{</span>b <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>P b<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>P <span class="ot">(</span>Succ b<span class="ot">)))</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>P a<span class="ot">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>ℕ-induction P Zero p[zero] p[succ] <span class="ot">=</span> p[zero]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ℕ-induction P <span class="ot">(</span>Succ n<span class="ot">)</span> p[zero] p[succ]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> p[succ] <span class="ot">(</span>ℕ-induction P n p[zero] p[succ]<span class="ot">)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>Succ-inj <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>Succ n<span class="ot">)</span> ≡ <span class="ot">(</span>Succ m<span class="ot">)</span> <span class="ot">→</span> n ≡ m</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>Succ-inj refl <span class="ot">=</span> refl</span></code></pre></div>
<p>This is much as we might expect, induction is identical to the recursion principle for <span class="math inline">\(\mathbb{N}\)</span> and <span class="math inline">\(\mathrm{Succ}\)</span>-<span class="math inline">\(\mathrm{inj}\)</span> follows definitionally after we case match on equality. We can now make <span class="math inline">\(\mathbb{N}\)</span> an instance of <span class="math inline">\(\mathrm{Peano}\)</span>:</p>
<pre><code>instance
  ℕ-Peano : Peano ℕ
  ℕ-Peano =
    record
      { zero           = Zero
      ; succ           = Succ
      ; s-injective    = Succ-inj
      ; zero≠succ      = λ n ()
      ; induction      = ℕ-induction
      ; induction-zero = λ P z s   → refl
      ; induction-succ = λ P a z s → refl
      }</code></pre>
<p>In the last two cases, the <span class="math inline">\(\mathrm{induction}\)</span> laws hold definitionally from how we have defined <span class="math inline">\(\mathbb{N}\)</span>-<span class="math inline">\(\mathrm{induction}\)</span>.</p>
<p>Now, suppose <span class="math inline">\(\mathsf{N}\)</span> is a set satisfying the Peano axioms, we want to then define functions to and from <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>from-ℕ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> N</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>from-ℕ <span class="ot">{</span>N<span class="ot">}</span> n <span class="ot">=</span> induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">-&gt;</span> N<span class="ot">)</span> n zero succ</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>to-ℕ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{_</span> <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">→</span> N <span class="ot">→</span> ℕ</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>to-ℕ n <span class="ot">=</span> induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> n zero succ</span></code></pre></div>
<p>Pleasantly both definitions are essentially identical, using instance resolution to determine the relevant induction principle and values to use. Here we see the power of constructive induction. We don’t use induction to prove a <em>property</em> per se, but to compute. Since the dependent types in question are constant, induction simply <em>is</em> recursion!</p>
<p>Now we can show these maps form equivalences. To get a flavour let us step through the development for the first equality:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>to∘from <span class="ot">:</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> to-ℕ <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-ℕ n<span class="ot">)</span> ≡ n</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>to∘from n <span class="ot">=</span> <span class="ot">{!!}</span></span></code></pre></div>
<p>Asking Agda for the goal gives us:</p>
<pre class="terminal"><code>Goal: Peano.induction peano (λ _ → ℕ)
      (ℕ-induction (λ _ → N) n (Peano.zero peano) (Peano.succ peano)) 0
      Succ
      ≡ n
————————————————————————————————————————————————————————————
n     : ℕ
peano : Peano N  (not in scope, instance)
_     : EqRel N    (instance)
N     : Set      (not in scope)
</code></pre>
<p>We can see that in order for <span class="math inline">\(\mathbb{N}\)</span>-<span class="math inline">\(\mathrm{induction}\)</span> to make progress we need to split on <span class="math inline">\(\mathrm{n}\)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>to∘from <span class="ot">:</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> to-ℕ <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-ℕ n<span class="ot">)</span> ≡ n</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>to∘from Zero     <span class="ot">=</span> <span class="ot">{!!}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>to∘from <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">{!!}</span></span></code></pre></div>
<p>The new goal for <span class="math inline">\(\mathrm{Zero}\)</span> is:</p>
<pre class="terminal"><code>Goal: Peano.induction peano (λ _ → ℕ) (Peano.zero peano) 0 Succ ≡ 0</code></pre>
<p>But this is precisely our <span class="math inline">\(\mathrm{induction}\)</span>-<span class="math inline">\(\mathrm{zero}\)</span> principle! Similarly we can now use the <span class="math inline">\(\mathrm{induction}\)</span>-<span class="math inline">\(\mathrm{succ}\)</span> principle in the second case and then recurse giving us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>to∘from <span class="ot">:</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span> <span class="ot">_</span> <span class="ot">:</span> EqRel N <span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> to-ℕ <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>from-ℕ n<span class="ot">)</span> ≡ n</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>to∘from Zero <span class="ot">=</span>  <span class="ot">(</span>induction-zero <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>to∘from <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_}}</span> <span class="ot">{{</span>peano<span class="ot">}}</span> <span class="ot">(</span>Succ n<span class="ot">)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>induction-succ</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(</span>ℕ-induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> N<span class="ot">)</span> n <span class="ot">(</span>Peano<span class="ot">.</span>zero peano<span class="ot">)</span> <span class="ot">(</span>Peano<span class="ot">.</span>succ peano<span class="ot">))</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>      Zero</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>      Succ<span class="ot">)</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">|</span> to∘from <span class="ot">{</span>N<span class="ot">}</span> n</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> refl</span></code></pre></div>
<p>The slightly gnarly explicit arguments in the second case are to help along the rewrite construction as it didn’t seem to cooperate with a less verbose alternative.</p>
<p>The other proof is similarly a case of following our nose (or rather following the typechecker). We first remind ourselves of some equality principles we have imported above (again simplifying away level polymorphism):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Funtions preserve equality:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>cong</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">{</span>x y <span class="ot">:</span> A<span class="ot">}</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> x ≡ y <span class="ot">→</span> f x ≡ f y</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- The transitivity principle for ≡</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>trans <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b c <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> a ≡ b <span class="ot">→</span> b ≡ c <span class="ot">→</span> a ≡ c</span></code></pre></div>
<p>We also will need the fact that we can lift any propositional equality into an equivalence relation:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>liftEq <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>  <span class="ot">{{</span>r <span class="ot">:</span> EqRel A<span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{</span>a b <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> a ≡ b <span class="ot">→</span> <span class="ot">(</span>a ≃ b<span class="ot">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>liftEq refl <span class="ot">=</span> reflexivity</span></code></pre></div>
<p>With these can now give the proof:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>from∘to <span class="ot">:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">{</span>N <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{{</span> rel <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">→</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">→</span> <span class="ot">(</span>n <span class="ot">:</span> N<span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  from-ℕ <span class="ot">(</span>to-ℕ n<span class="ot">)</span> ≃ n</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>from∘to <span class="ot">{</span>N<span class="ot">}</span> n <span class="ot">=</span> liftEq <span class="ot">(</span>prop-eq <span class="ot">{</span>N<span class="ot">})</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>             <span class="co">-- We make use of liftEq as we prove the</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>             <span class="co">-- stronger claim that from-ℕ (to-ℕ n) ≡ n</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- In the zero case we apply induction-zero underneath from-ℕ</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and then use the definition of from-ℕ.</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  zero-lem</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> from-ℕ <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(</span>induction <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> zero Zero Succ<span class="ot">)</span> ≡ zero</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  zero-lem <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">:</span> from-ℕ <span class="ot">(</span>induction <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> zero Zero Succ<span class="ot">)</span> ≡ from-ℕ Zero</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">=</span> cong from-ℕ <span class="ot">(</span>induction-zero <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">:</span> from-ℕ Zero ≡ zero</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">=</span> refl</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>      trans pf1 pf2</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- In the successor case we similarly apply induction-succ</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- underneath from-ℕ and then recurse on the previous proof.</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  succ-lem</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span> <span class="ot">(</span>prev <span class="ot">:</span> N<span class="ot">)</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> from-ℕ <span class="ot">(</span>induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> prev Zero Succ<span class="ot">)</span> ≡ prev</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> from-ℕ <span class="ot">(</span>induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> <span class="ot">(</span>succ prev<span class="ot">)</span> Zero Succ<span class="ot">)</span> ≡ succ prev</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  succ-lem prev pf <span class="ot">=</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">:</span> from-ℕ <span class="ot">(</span>induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> <span class="ot">(</span>succ prev<span class="ot">)</span> Zero Succ<span class="ot">)</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>          ≡ from-ℕ <span class="ot">(</span>Succ <span class="ot">(</span>induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> prev Zero Succ<span class="ot">))</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>      pf1 <span class="ot">=</span> cong from-ℕ <span class="ot">(</span>induction-succ <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> prev Zero Succ<span class="ot">)</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">:</span> from-ℕ <span class="ot">(</span>Succ <span class="ot">(</span>induction <span class="ot">(λ</span> <span class="ot">_</span> <span class="ot">→</span> ℕ<span class="ot">)</span> prev Zero Succ<span class="ot">))</span> ≡ <span class="ot">(</span>succ prev<span class="ot">)</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>      pf2 <span class="ot">=</span> cong succ pf</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>      trans pf1 pf2</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>  prop-eq</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>N<span class="ot">}</span> <span class="ot">{{_</span> <span class="ot">:</span> EqRel N<span class="ot">}}</span> <span class="ot">{{</span>peano <span class="ot">:</span> Peano N<span class="ot">}}</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> from-ℕ <span class="ot">(</span>to-ℕ n<span class="ot">)</span> ≡ n</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>  prop-eq <span class="ot">=</span></span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>      induction</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- we use induction on the principle</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- we are trying to show with the above</span></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- lemmas.</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(λ</span> n <span class="ot">→</span> from-ℕ <span class="ot">(</span>to-ℕ  n<span class="ot">)</span> ≡ n<span class="ot">)</span></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>        n</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>        zero-lem</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(λ</span> <span class="ot">{</span>prev<span class="ot">}</span> <span class="ot">→</span> succ-lem prev<span class="ot">)</span></span></code></pre></div>
<p>This shows that any two types which satisfy the Peano axioms are equivalent in the sense that there are maps between them which form an isomorphism up to equivalence.</p>
<p>This is quite interesting as it stands, but we might wonder if there is a more direct characterization of the natural numbers. After all, our original definition as a recursive algebraic data type seems to give a perfectly good specification of what the natural numbers <em>are</em>. Let us turn to a characterization of <span class="math inline">\(\mathbb{N}\)</span> given by Lawvere.</p>
<p>We define the category of discrete dynamical systems, whose:</p>
<ul>
<li>Objects are sets <span class="math inline">\(X\)</span> equipped with a starting point <span class="math inline">\(x_0 \in X\)</span> and a self-map <span class="math inline">\(f : X \rightarrow X\)</span>.</li>
<li>Morphisms are functions <span class="math inline">\(\phi : X \rightarrow Y\)</span> which take basepoint to basepoint and which commute with the self-map: <span class="math display">\[
\begin{array}{lll}
X          &amp; \xrightarrow{\phi} &amp; Y      \\
\downarrow &amp;             &amp; \downarrow    \\
X          &amp; \xrightarrow{\phi} &amp; Y      \\
\end{array}
\]</span></li>
</ul>
<p>Lawvere then observed that the natural numbers are the <a href="https://ncatlab.org/nlab/show/initial+object">initial object</a> in the category of discrete dynamical systems. In other words, every other dynamical system receives a <em>unique</em> map from the discrete dynamical system <span class="math inline">\(\left( \mathbb{N}\; , \; 0 : \mathbb{N}\; ,\; \mathrm{s}\; : \; \mathbb{N} \rightarrow \mathbb{N}\right)\)</span>.</p>
<p>Let us phrase this idea in terms of language more familiar to functional programmers. First define a “pattern functor” for <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> NatP <span class="ot">(</span>r <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  ZeroP <span class="ot">:</span> NatP r</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  SuccP <span class="ot">:</span> r <span class="ot">→</span> NatP r</span></code></pre></div>
<p>This has the same shape as <span class="math inline">\(\mathbb{N}\)</span> but we leave the recursion open (this same pattern of open recursion is the animating idea behind <a href="https://hackage.haskell.org/package/recursion-schemes">recursion schemes</a>). We can show that this is a functor (we don’t worry about the functor laws):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Functor <span class="ot">(</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Set₁ <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> Func</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    Arr <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>f <span class="ot">:</span> A <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> F A <span class="ot">→</span> F B</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Functor <span class="ot">{{...}}</span> <span class="kw">public</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  NatP-Functor <span class="ot">:</span> Functor NatP</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  NatP-Functor <span class="ot">=</span> Func map</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    map <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> NatP A <span class="ot">→</span> NatP B</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    map f ZeroP     <span class="ot">=</span> ZeroP</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    map f <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> SuccP <span class="ot">(</span>f x<span class="ot">)</span></span></code></pre></div>
<p>Functional programmers might recognise that the discrete dynamical systems discussed above are in fact <a href="https://en.wikipedia.org/wiki/F-algebra"><span class="math inline">\(\mathrm{F}\)</span>-algebras</a> for this pattern functor, which we define as follows:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Alg <span class="ot">(</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    μ <span class="ot">:</span> F A <span class="ot">→</span> A</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Alg <span class="ot">{{...}}</span> <span class="kw">public</span></span></code></pre></div>
<p>In particular if we define discrete dynamical systems:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Dyn <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> D</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    basepoint <span class="ot">:</span> A</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    self-map  <span class="ot">:</span> A <span class="ot">→</span> A</span></code></pre></div>
<p>then we can show then any dynamical system gives rise to an algebra:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>from-Dyn <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> Dyn A <span class="ot">→</span> Alg NatP A</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>from-Dyn <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">(</span>D basepoint self-map<span class="ot">)</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> μ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">:</span> NatP A <span class="ot">→</span> A</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  alg ZeroP     <span class="ot">=</span> basepoint</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">(</span>SuccP a<span class="ot">)</span> <span class="ot">=</span> self-map a</span></code></pre></div>
<p>and we leave, as an exercise, to show that there is an isomorphism between <span class="math inline">\(\mathrm{NatP}\)</span> algebra structures on <span class="math inline">\(\mathrm{A}\)</span> and discrete dynamical system structures (an observation we can upgrade to an isomorphism between the respective categories).</p>
<p>Let’s give the algebra structure for <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  ℕ-Alg <span class="ot">:</span> Alg NatP ℕ</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  ℕ-Alg <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> μ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">:</span> NatP ℕ <span class="ot">→</span> ℕ</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    alg ZeroP     <span class="ot">=</span> Zero</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> Succ x</span></code></pre></div>
<p>Just as in Lawvere’s characterization, we now wish to show that this algebra is initial. For that, we first have to define maps between algebras. Suppose <span class="math inline">\(\mathrm{A}\)</span> and <span class="math inline">\(\mathrm{B}\)</span> are <span class="math inline">\(\mathrm{F}\)</span>-algebras. We then say a map <span class="math inline">\(m : \mathrm{A} \rightarrow \mathrm{B}\)</span> is an <span class="math inline">\(\mathrm{F}\)</span>-algebra homomorphism when the following diagram commutes (where the downward arrows are the algebra maps):</p>
<p><span class="math display">\[
\begin{array}{lll}
F A          &amp; \xrightarrow{F m} &amp; F B  \\
\downarrow &amp;             &amp; \downarrow   \\
A          &amp; \xrightarrow{m} &amp; B        \\
\end{array}
\]</span></p>
<p>In other words, the algebra map commutes with the map in question, or in equations: <span class="math display">\[
f \circ \mu_{A} \equiv \mu_{B} \circ (F f)
\]</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Alg-Homo <span class="ot">(</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">{</span>F <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{{</span>f <span class="ot">:</span> Functor F<span class="ot">}}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(</span>FA <span class="ot">:</span> Alg F A<span class="ot">)</span> <span class="ot">(</span>FB <span class="ot">:</span> Alg F B<span class="ot">)</span> <span class="ot">:</span> Set₁ <span class="kw">where</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> AlgHom</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    →-fun  <span class="ot">:</span> A <span class="ot">→</span> B</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    μ-comm</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>fa <span class="ot">:</span> F A<span class="ot">)</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">→</span> →-fun <span class="ot">(</span>Alg<span class="ot">.</span>μ FA fa<span class="ot">)</span> ≡ <span class="ot">(</span>Alg<span class="ot">.</span>μ FB<span class="ot">)</span> <span class="ot">(</span>Arr →-fun fa<span class="ot">)</span></span></code></pre></div>
<p>Now we can try to prove that the algebra structure on <span class="math inline">\(\mathbb{N}\)</span> is initial. We first show there is an induced map to every other <span class="math inline">\(\mathrm{F}\)</span>-<span class="math inline">\(\mathrm{algebra}\)</span>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>ℕ-weakly-initial</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg NatP A<span class="ot">}}</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> Alg-Homo ℕ A ℕ-Alg FA</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>ℕ-weakly-initial <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> AlgH init-ℕ law</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  init-ℕ <span class="ot">:</span> ℕ <span class="ot">→</span> A</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  init-ℕ Zero     <span class="ot">=</span> μ ZeroP</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  init-ℕ <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span> μ <span class="ot">(</span>SuccP <span class="ot">(</span>init-ℕ n<span class="ot">))</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">:</span> <span class="ot">(</span>nP <span class="ot">:</span> NatP ℕ<span class="ot">)</span> <span class="ot">→</span> init-ℕ <span class="ot">(</span>μ nP<span class="ot">)</span> ≡ μ <span class="ot">(</span>Arr init-ℕ nP<span class="ot">)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  law ZeroP     <span class="ot">=</span> refl</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">(</span>SuccP x<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>We define the map via the structure of the algebra. <span class="math inline">\(\mathrm{Zero}\)</span> maps to the basepoint of <span class="math inline">\(\mathrm{A}\)</span> and for the successor we apply the self-map and then recurse. For the <span class="math inline">\(\mu\)</span>-<span class="math inline">\(\mathrm{law}\)</span> we first case split as this is how <span class="math inline">\(\mathrm{init}\)</span>-<span class="math inline">\(\mathbb{N}\)</span> is defined. At this point we can see that the laws hold definitionally from how we have defined the map.</p>
<p>We can then show uniqueness:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>ℕ-init-uniq <span class="ot">:</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">∀</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg NatP A<span class="ot">}}</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>alg-hom <span class="ot">:</span> Alg-Homo ℕ A ℕ-Alg FA<span class="ot">)</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">(</span>Alg-Homo<span class="ot">.</span>→-fun alg-hom n<span class="ot">)</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  ≡ <span class="ot">(</span>Alg-Homo<span class="ot">.</span>→-fun <span class="ot">(</span>ℕ-weakly-initial <span class="ot">{{</span>FA<span class="ot">}})</span> n<span class="ot">)</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>ℕ-init-uniq alg-hom Zero <span class="ot">=</span> μ-comm ZeroP</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">open</span> Alg-Homo alg-hom <span class="kw">public</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>ℕ-init-uniq <span class="ot">{{</span>FA<span class="ot">}}</span> alg-hom <span class="ot">(</span>Succ n<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">:</span>  →-fun <span class="ot">(</span>Succ n<span class="ot">)</span> ≡ μ <span class="ot">(</span>SuccP <span class="ot">(</span>→-fun n<span class="ot">))</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">=</span> μ-comm <span class="ot">(</span>SuccP n<span class="ot">)</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">:</span>  μ <span class="ot">(</span>SuccP <span class="ot">(</span>→-fun n<span class="ot">))</span> ≡ μ <span class="ot">(</span>SuccP <span class="ot">(</span>Alg-Homo<span class="ot">.</span>→-fun ℕ-weakly-initial n<span class="ot">))</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">=</span> cong <span class="ot">(</span>μ ∘ SuccP<span class="ot">)</span> <span class="ot">(</span>ℕ-init-uniq alg-hom n<span class="ot">)</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    trans pf1 pf2</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">open</span> Alg-Homo alg-hom <span class="kw">public</span></span></code></pre></div>
<p>We don’t infer algebra homomorphisms and so we need to pass them as arguments and open the various records to bring their fields into scope. In the first case we have the following goal:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>→-fun <span class="dv">0</span> ≡ μ ZeroP</span></code></pre></div>
<p>We note that this is definitionally equivalent to showing:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>→-fun <span class="ot">(</span>μ ZeroP<span class="ot">)</span> ≡ μ <span class="ot">(</span>Arr →-fun ZeroP<span class="ot">)</span></span></code></pre></div>
<p>and this is the <span class="math inline">\(\mu\)</span>-<span class="math inline">\(\mathrm{comm}\)</span> law!</p>
<p>In the successor case we have to prove:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>→-fun <span class="ot">(</span>Succ n<span class="ot">)</span> ≡ μ <span class="ot">(</span>SuccP <span class="ot">(</span>Alg-Homo<span class="ot">.</span>→-fun ℕ-weakly-initial n<span class="ot">))</span></span></code></pre></div>
<p>We use a similar observation as above to first rewrite the left-hand-side using the <span class="math inline">\(\mu\)</span>-<span class="math inline">\(\mathrm{comm}\)</span> law. At that point (as before) we can rewrite the inner part by recursion.</p>
<p>One nice thing about this characterization (beyond being much simpler to reason about!) is that the same idea of initial algebra semantics works just as well for any algebraic data type. For example we can do exactly the same for lists as we have for <span class="math inline">\(\mathbb{N}\)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> ListP <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>r <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  NilP  <span class="ot">:</span> ListP A r</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  ConsP <span class="ot">:</span> A <span class="ot">→</span> r <span class="ot">→</span> ListP A r</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  Nil  <span class="ot">:</span> List A</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  Cons <span class="ot">:</span> A <span class="ot">→</span> List A <span class="ot">→</span> List A</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  ListP-Functor <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">→</span>  Functor <span class="ot">(</span>ListP A<span class="ot">)</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  ListP-Functor <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> Func map-L</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    map-L <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">{</span>C<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>B <span class="ot">→</span> C<span class="ot">)</span> <span class="ot">→</span> ListP A B <span class="ot">→</span> ListP A C</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    map-L f NilP <span class="ot">=</span> NilP</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    map-L f <span class="ot">(</span>ConsP a b<span class="ot">)</span> <span class="ot">=</span> ConsP a <span class="ot">(</span>f b<span class="ot">)</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> HasFold <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Set₁ <span class="kw">where</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> F</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    initial  <span class="ot">:</span> B</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    operator <span class="ot">:</span> A <span class="ot">→</span> B <span class="ot">→</span> B</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>fromHasFold <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span>  HasFold A B <span class="ot">→</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>fromHasFold <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">(</span>F initial operator<span class="ot">)</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> μ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">:</span> ListP A B <span class="ot">→</span> B</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>  alg NilP <span class="ot">=</span> initial</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>  alg <span class="ot">(</span>ConsP a b<span class="ot">)</span> <span class="ot">=</span> operator a b</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>toHasFold <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B <span class="ot">→</span> HasFold A B</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>toHasFold <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="kw">record</span> <span class="ot">{</span> μ <span class="ot">=</span> μ <span class="ot">}</span> <span class="ot">=</span> F init op</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>  init <span class="ot">:</span> B</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>  init <span class="ot">=</span> μ NilP</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>  op <span class="ot">:</span> A <span class="ot">→</span> B <span class="ot">→</span> B</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>  op a b <span class="ot">=</span> μ <span class="ot">(</span>ConsP a b<span class="ot">)</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>  List-Alg <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">→</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> <span class="ot">(</span>List A<span class="ot">)</span></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>  List-Alg <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span> μ <span class="ot">=</span> alg <span class="ot">}</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">:</span> ListP A <span class="ot">(</span>List A<span class="ot">)</span> <span class="ot">→</span> List A</span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    alg NilP <span class="ot">=</span> Nil</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>    alg <span class="ot">(</span>ConsP a as<span class="ot">)</span> <span class="ot">=</span> Cons a as</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>foldr <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> B <span class="ot">→</span> List A <span class="ot">→</span> B</span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>foldr op init Nil         <span class="ot">=</span> init</span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>foldr op init <span class="ot">(</span>Cons a as<span class="ot">)</span> <span class="ot">=</span> op a <span class="ot">(</span>foldr op init as<span class="ot">)</span></span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>foldr-Alg <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B<span class="ot">}}</span></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> List A <span class="ot">→</span> B</span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>foldr-Alg <span class="ot">=</span> foldr <span class="ot">(λ</span> a b <span class="ot">→</span> μ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>μ NilP<span class="ot">)</span></span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>List-weakly-initial</span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">{{</span>FA <span class="ot">:</span> Alg <span class="ot">(</span>ListP A<span class="ot">)</span> B<span class="ot">}}</span></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> Alg-Homo <span class="ot">(</span>List A<span class="ot">)</span> B <span class="ot">(</span>List-Alg <span class="ot">{</span>A<span class="ot">})</span> FA</span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>List-weakly-initial <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">=</span> AlgHom foldr-Alg law</span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">:</span> <span class="ot">(</span>fa <span class="ot">:</span> ListP A <span class="ot">(</span>List A<span class="ot">))</span> <span class="ot">→</span></span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a>    foldr <span class="ot">(λ</span> a b <span class="ot">→</span> μ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>μ NilP<span class="ot">)</span> <span class="ot">(</span>μ fa<span class="ot">)</span></span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a>      ≡</span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a>    μ <span class="ot">(</span>Arr <span class="ot">(</span>foldr <span class="ot">(λ</span> a b <span class="ot">→</span> μ <span class="ot">(</span>ConsP a b<span class="ot">))</span> <span class="ot">(</span>μ NilP<span class="ot">))</span> fa<span class="ot">)</span></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a>  law NilP         <span class="ot">=</span> refl</span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a>  law <span class="ot">(</span>ConsP a as<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>and we see that out of initiality naturally comes <span class="math inline">\(\mathrm{foldr}\)</span>! <span class="math inline">\(\mathrm{F}\)</span>-algebra semantics give rise to <em>recursion principles</em>! The essence of <span class="math inline">\(\mathbb{N}\)</span>, from this point of view, lies in its recursive structure. After all, in a dependently-typed setting recursion and induction are really two sides of the same coin.</p>
<p>Thank you for reading! The full code for these examples is available <a href="https://github.com/Boarders/agda-peano/blob/master/Peano.agda">here</a>. Hopefully this has given some ideas for how we can explore mathematical ideas in Agda leveraging the typechecker to guide our proofs. Feel free to contact me <a href="mailto:callan.mcgill@gmail.com">here</a> with questions, thoughts, ideas, or all of the above.</p>
<p><i>With warmest thanks to Sam Derbyshire, Reed Mullanix, Alixandra Prybyla and Shon Feder for their valuable feedback.</i></p>]]></content>
  </entry>
</feed>
